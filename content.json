{"pages":[],"posts":[{"title":"Organizing Containers of Balls","text":"해커랭크 문제 풀이 📝 Organizing Containers of Balls (30.0) 주어진 2차원 container 배열을 따라 각 container ballType의 갯수에 따라 분배되는데 공을 교환해서 각 컨테이너가 가질수 있는 ballType이 한가지가 될 수 있는 경우 Possible/Impossible을 출력하는 문제 였다. 💣 헤맸던 점 문제 푸는 시간 자체는 얼마 안걸렸는데 - Each container contains only balls of the same type. - No two balls of the same type are located in different containers. 문장해석을 실수 해서 시원하게 한번에 풀진 못했다. 처음에 이해한 문제는 0c 1c 2c 각 컨테이너 번호 당 가지고있는 공을 0타입 1타입 2타입 이라고 봤을때 같은 번호의 공을 가지고 있어야하는 조건으로 판단해서 각 컨테이너당 가지고 있는 자신이 아닌 번호의 ballType을 집계하고 다른 컨테이너에 있는 자신의 타입 ballType 공 갯수가 같을때를 Possible로 보고 풀었다. Submit하고 풀었는데 이번 예제는 TestCase가 너무 터무니없이 나와있어서 어디서 틀렸는지 많이 해맸다. 풀이에서 나오듯 ArrayList 객체를 만들어서 풀었는데 처음에는 if문 조건 판별시 ArrayList.get(index)로 작성했는데 조건에 상관없이 무조건 true로 판정되어 Impossible이 리턴되는 문제가 있었다. Int와 int의 차이, 레퍼런스 타입의 문제를 놓쳐 시간을 조금 잡아먹었는데 자바에서 첫글자가 대문자 -&gt; 클래스 -&gt; 레퍼런스 counting.get(index).intValue() != ballType.get(index).intValue() 이나 int 변수를 초기화해 사용해 풀었다. 💡 풀이 123456789101112131415161718192021222324252627282930313233343536373839404142static String organizingContainers(int[][] container) { List&lt;Integer&gt; ballType = new ArrayList&lt;&gt;(); List&lt;Integer&gt; counting = new ArrayList&lt;&gt;(); for(int x=0; x&lt;container.length; x++){ int count = 0; for(int y=0; y&lt;container[x].length; y++){ count += container[x][y]; } counting.add(count); } for(int i=0; i&lt;container.length; i++){ int ball = 0; for(int j=0; j&lt;container[i].length; j++){ ball += container[j][i]; } ballType.add(ball); } Collections.sort(counting); Collections.sort(ballType); for (int k = 0; k &lt; counting.size(); k++) { int contain = counting.get(k); int type = ballType.get(k); if (contain != type) { return \"Impossible\"; } } return \"Possible\"; } 예제를 보고 몇번 대입해보니 문제자체는 쉬웠다. 각 컨테이너가 가지고있는 공의 갯수를 구한뒤 각 ballType마다 공의 갯수를 구해 컨테이너들이 가지고있는 공의 갯수와 ballType의 공의 갯수가 일치한다면 Possible 일치하지않는다면 Impossible을 리턴하는것으로 풀었다.","link":"/2019/01/21/18.01.22 Organizing Containers of Balls/"},{"title":"FrogRiverOne ","text":"HashSet을 이용한 문제 풀이 FrogRiverOne Codility에서 내가 푼 문제를 못보는줄 알고있었는데결과창 링크가 따로 생성되서 그 링크에 들어가면 결과를 볼 수 있는걸어제 알았다 :( 문제를 요약하자면 징검다리를 건너려는개구리가 1초마다 특정 위치에 떨어지는 나뭇잎을 밟고 갈때X지점으로 가기위해 건널수 있는 가장 빠른 길을 반환하는거였다. 내가 생각한 방법은 이렇게 생각했다. 배열 A[i]에서 중복되는 값은 모두 0으로 만들었다. 문제에서는 원소가 같을 경우 같은 징검다리에 나뭇잎이 떨어지는 것을 의미하기 때문에 의미가 없기 때문이다. 그 다음 목표지점 X에 건널경우 개구리는 1 -&gt; 2 -&gt; 3 … -&gt; X 로 이동경로를 지나쳐 도달하게되는데이걸 1부터 X까지의 합으로 생각해서 sum을 계산했다. (이전의 포스팅인 PermMissingElem 에서 배운걸 이용해봤다.) 계산된 sum에서 배열 원소를 처음부터 하나씩 빼고 sum이 0이 되면 해당 i값을 반환한다. 123456789101112131415161718192021222324252627282930313233343536import java.util.*; // you can write to stdout for debugging purposes, e.g.// System.out.println(\"this is a debug message\"); class Solution { public int solution(int X, int[] A) { // write your code in Java SE 8 for (int i=0 ; i&lt;A.length; i++){ for(int j=0; j&lt;A.length; j++){ if(A[i]==A[j] &amp;&amp; i!=j &amp;&amp; A[i]!=0) { A[j] = 0; } } } int sum = (X*(X+1))/2; int flag = 0; for (int i=0; i&lt;A.length; i++){ sum -= A[i]; if (sum == 0){ flag = i; i = A.length; } } if(sum &gt;0) { return -1; } return flag; }} 결과는 54점 퍼포먼스 부분 점수가 낮았다.중복을 없애는 과정에서 배열의 길이가 클 경우에는 시간이 오래걸려 그런것이었다. 100% 예제를 봤는데 HashSet을 이용한 예제 였다. 12345678910111213141516171819202122import java.util.*; // you can write to stdout for debugging purposes, e.g.// System.out.println(\"this is a debug message\"); class Solution { public int solution(int X, int[] A) { Set&lt;Integer&gt; marks = new HashSet&lt;&gt;(); for (int i = 0; i &lt; A.length; i++) { if (A[i] &lt;= X) { marks.add(A[i]); if (marks.size() == X) { return i; } } } return -1;} } HashSet을 이용해 X보다 자거나 같은 원소들을 추가해중복이 없는 marks를 만들고 marks의 사이즈와 X값이 일치할때!i값을 반환하는 것이다. HashSet은 처음 사용해 봤는데 Hash에 관한 정리를 다시해봐야 겠다.","link":"/2018/05/18/18.05.18 FrogRiverOne/"},{"title":"Static Resource의 내용이 변하지 않는 경우.","text":"The content of the Static Resource does not change. ( CSS, IMG, ETC … ) JSP페이지에 내장된 요소들의 CSS를 변경하기 위해 CSS파일을 수정하던중 처음겪는 경우여서 포스팅 해본다. 123451. View 요소에 CSS를 변경하려고 /src/main/resources/static/css 의 경로에 위치한 CSS 파일을 수정했다.2. CSS파일의 수정사항이 반영되지 않았다.3. CSS파일을 삭제하거나 이름을 바꿔도 이전의 CSS들이 적용됬다. 처음에는 CSS파일의 경로가 잘못됬나하고 생각해봤는데 그럴일은 없었다. 일단 이전의 CSS파일은 인식되고 있는 상태였기 때문에 경로 문제는 아니었다. 헤드부분에는 이런식으로 경로가 적용되있었는데, &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;/&gt; /src/main/resources/static/css 와 “/css/style.css” 가 맞지않고 다른 경로에있는 css파일과 매칭됬나? 했는데 다른 style.css가 있는것도 아니었다. 크롬탭에서 콘솔로 뭐가 문젠가 20~30분은 해매다가 우연히 해결했다. 문제가 된 이유는 수정된 파일을 배포하더라도, 기존의 이용하던 브라우저에 캐쉬가 남아서(Stale Cache) 수정된 파일이 작동하지 않는것이었다. 내 경우에는 크롬에 내장되있는 캐쉬삭제를 통해 해결했는데, 검색해보니 다른 좋은 해결방법이 있어서 이것도 올려본다. &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;/&gt;문제가 됐었던 태그의 내용인데, 이렇게 하게되면 Stale Cache에 관한 문제가 계속 발생할 가능성이 생긴다. 그때마다 캐쉬를 삭제하는것 보다는 이 문제를 방지하기위해 &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css?ver=1.0&quot;/&gt;이런식으로 version에 대한 쿼리스트링을 추가할수도 있다. 이 경우 version에 대한 정보를 인식받아 .css를 읽어오기 때문에 Stale Cache에 관한 문제점이 없어져 좋은 해결책으로 보인다. 나중에 알게 된건데, 크롬에서는 Ctrl+F5키를 누르면 캐시까지 새로고침한다.아주 유용하게 쓰고있는 기능 :)","link":"/2018/04/06/18.04.07 Static Resource의 내용이 변하지 않는 경우./"},{"title":"JSON을 다루면서 겪었던 실수","text":"JSONARRAY로 리턴된 검색결과를 다룰때 한 실수 새로운 프로젝트를 진행하면서 API를 다루며 웹프로젝트를 진행하던 중 난감한 상황을 맞이했다. 이전에 블로그 만들기를 진행했었을때 로그인기능은 페이스북 API를 이용해 JSONObject만 을 리턴 받아 구현했었다. JSONARRAY 객체로 표현된 것이 없어서 비교적 쉽게 JSONObject.get(“key”)값을 이용해 리턴받은 결과들의 데이터를 조작할수 있었지만, 이번 경우는 달랐다. 검색기능 수행한 결과가 JSONARRAY** 를 통해 결과들이 나열된 형식으로 표현된 것이었다. 처음에는 파라미터를 정해놓고 파싱을 어떻게 할지 생각했었기 때문에 일어난 실수 였다. 결국 여러 시행착오를 겪으며 해결했고, JSONArray 파싱에 대한 글은 많이 없는것 같아서 글을 남겨본다. 파싱과정은 다음과 같이 수행하였다. 12345JSONParser jsonParser = new JSONParser();JSONObject jsonObject = (JSONObject) jsonParser.parse(json);JSONArray rowArray = (JSONArray) jsonObject.get(&quot;rows&quot;);JSONObject dataobj = (JSONObject) rowArray.get(index); 2: 파싱받고 싶은 JSON페이지를 JSONParser로 받고 3: rows라는 이름을 통해 JSONArray객체를 선정한뒤, 5: 해당 객체에서 결과값을 받고싶은 오브젝트의 index를 입력받는다. 그 후 , 아래와 같이 index입력을 통해 받은 JSONObject 객체에서 key를 뽑아 데이터를 관리하면 된다. 처음에는 JSONArray에서 바로 JSONObject를 리턴받으려고 했었는데 결과값이 여러개일 경우를 생각하지 못해서 생긴 실수 였다. index를 입력받는 과정을 통해 어느 객체의 정보가 필요한지 명시해 주어야 원하는 정보를 얻을 수 있다. 너무 초보적인, 실수라고 부르기도 뭐했지만 그래도 블로그에 남겨본다 ㅠ","link":"/2018/03/13/18.03.14 JSON을 다루면서 겪었던 실수/"},{"title":"OddOccurrencesInArray","text":"HashMap을 이용한 문제 풀이 블로그를 만들어놨는데 한동안 포스팅이 없었다. 뭘 포스팅할지 결정하는걸 자체를 미루기도 했었지만 포스팅을 하다가도 애초에 블로그를 만들었던 목적과는 다른 포스팅이 되는것 같아 글을 쓰다가 접어버린 경우도 꽤 있었다. 알고리즘 공부를 하면서 Codility라는 사이트를 알게 됐는데 내가 작성한 문제, 코드를 다시보는 기능이 없는것 같아 앞으로 잘 안풀려서 참고했던 코드나, 풀었는데 점수가 낮았던 경우들을 포스팅할려고 한다. OddOccurrencesInArray 는 Array lesson2에 있는 문제인데 요약해서 이해해보자면, int []A로 된 배열에 원소들중 짝을 이루지않고있는 원소를 찾는것이다. 내 풀이 과정은 이랬다. 123451. A배열의 원소들을 비교해 같은 값을 가진 원소의 갯수를 B배열에 따로 만든다. - ex) A={1,2,3,4,4,5} 이면 B배열에 원소마다 A배열의 원소가 가진 같은 원소의 갯수를 채워넣는 것이다.2. B배열을 통해 짝이 없는 A배열의 원소 인덱스를 파악하고, 같은 인덱스의 A배열 인덱스를 반환한다. 풀이과정을 쓰려고 하니까 설명이 굉장히 어렵다 :( 1234567891011121314151617181920212223242526272829303132import java.util.*; class Solution { public int solution(int[] A) { // write your code in Java SE 8 int[] B = new int[A.length]; int count=0; int even = 0; for(int i =0 ; i&lt;=A.length-1; i++) { count = 0; for(int j = 0 ; j&lt;=B.length-1; j++) { if(A[i] == A[j] &amp;&amp; i!=j) { count++; } } B[i] = count+1; //A[]배열에서 A[i]와 같은 값을 가진 원소의 갯수 if(B[i] == 1) { even = A[i]; } } return even; }} 문제를 풀어보고 다른분이 푼 풀이도 봤는데 (by speedpak) HaspMap을 쓴 풀이 과정이 제일 깔끔하게 풀수있었던 방법이었던것 같다. 123456789101112131415161718192021222324252627282930313233import java.util.HashMap;import java.util.Map; /** * @author Deepak * */public class OddOccurrencesInArray { public static int solution(int[] A) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; A.length; i++) { if (map.containsKey(A[i])) { map.put(A[i], map.get(A[i]) + 1); } else { map.put(A[i], 1); } } Integer v = null; for (Map.Entry&lt;Integer, Integer&gt; m : map.entrySet()) { if (m.getValue() % 2 != 0) { v = m.getKey(); break; } } return v; } public static void main(String[] args) { int[] ar = new int[] { 9, 3, 9, 3, 9, 7, 9 }; System.out.println(solution(ar)); }} HaspMap에 각 원소에 해당하는 갯수를 같이 put시켜놓으면 key와 value의 형태가 원소 : 갯수 이런형태로 만들어져 나머지 연산을 통해 짝이 없는 원소를 판별할수 있다.","link":"/2018/05/15/18.05.15 OddOccurrencesInArray/"},{"title":"PermMissingElem / TapeEquilibrium","text":"배열 원소들의 합을 이용한 문제 풀이 절대값의 비교와 연산의 효율에 관한 문제였는데 PermMissingElem를 풀고나서 점수가 낮았던 문제점이똑같이 생겨 TapeEquilibrium에서도 점수가 낮게나왔다. PermMissingElem에서는 A배열을 sort()하고,1부터 시작하는 변수 i를 이용해서변수와 해당 변수의 인덱스를 가진 A[i]와 값이 다르다면 그것을 반환하는 식으로 짰었다. 결과는 퍼포먼스, 오류도 몇개있었는데정렬을 쓰는것 자체가 성능측면에서 구리기도 해서 점수가 낮았다. 다른분이 푼 방식을 보면 by kninami 123456789101112class Solution { public int solution(int[] A) { long N = A.length +1; long totalSum = (N*(N+1))/2; for(int i=0; i&lt;A.length; i++){ totalSum -= A[i]; } return (int)totalSum; }} A배열의 모든 원소가 빠지지않을 경우의 합을 계산하고그 합에서 원소를 하나씩 빼면 마지막에 반환된 totalSum이 빠진 원소라는 알고리즘으로 완성시켰다. for문의 인덱스를 이용하는것 까지는 맞았는데합을 이용해서 진행하는건 생각 못해서 처음 생각난 sort를 이용했는데 이거 때문에 점수가 낮게 나온것 같다. TapeEquilibrium에서는P값에 해당하는 -빼기 나오기전의 front 부분과 -이후에 back부분을새로운 B배열의 원소에 집어넣어 sort()하는 걸로 만들었는데이것도 역시 퍼포먼스나 다른 점수들이 너무 낮게 나왔다 :( 앞의 예제에서 썼던 합을 이용해 풀이과정을 만들어 보려고 했는데최솟값을 어떻게 해야 결정 지을지 생각을 못해서 다른분의 예제를 참고했다. by 아브 1234567891011121314151617181920212223class Solution { public int solution(int[] A) { // write your code in Java SE 8 int front = 0; int back = 0; for(int i = 0 ; i &lt; A.length ; i++){ back += A[i]; } int minDiff = Integer.MAX_VALUE; int p = 1; for(int i = 1 ; i &lt; A.length ; i++){ front += A[i-1]; back -= A[i-1]; p = i; minDiff = Math.min(minDiff, Math.abs(front - back)); } return minDiff; }} minDiff = Math.min(minDiff, Math.abs(front - back) 을 이용해서for문에서 최솟값을 갱신시키는것과, A배열의 총합인 back 변수에서 p값에 따라 빠지게되는뒷부분의 연산을 간단하고 효율적으로 처리하신것 같다. back부분의 처리에 관해 다시 생각해보자면 for문을 돌면서 초기화가 아니라계속 연산되면서 A[0]값이 빠지고 A[1], A[2] … 값이 계속 빠지는 과정을 어떻게 해야될지가이번거에서는 제일 어려웠던것 같다.","link":"/2018/05/18/18.05.18 PermMissingElem TapeEquilibrium/"},{"title":"PermCheck","text":"배열을 이용한 문제풀이 PermCheck이번 문제는 처음으로 내가 짠 코드가 100%를 기록했다.사실 문제 자체가 MissingInteger랑 비슷해서 금방 풀었는데결과가 100%로 나오니까 기분이 진짜 좋았다 :) 문제를 요약해보자면주어진 배열 A가 순열인지 체크하는 문제였다. 내가 푼 방식은Boolean으로 된 배열 하나를 선언하고A원소들을 인덱스를 이용해 true값으로 채우는 것이었다. 문제에서 예시로든 A배열의 원소가 A의 길이보다 클 경우에순열이 될수 없기 때문에 바로 0을 반환하는 코드를 추가할수 있었다. 운이 좋았다 :) 123456789101112131415161718192021222324class Solution { public int solution(int[] A) { // write your code in Java SE 8 boolean check[] = new boolean[A.length+1]; for (int i=0 ; i&lt;A.length; i++){ if(A[i] &gt; A.length){ return 0; } check[A[i]] = true; } for (int i=1 ; i&lt;check.length ; i++){ if( check[i] == false ){ return 0; } } return 1; }}","link":"/2018/05/22/18.05.22 PermCheck/"},{"title":"MissingInteger","text":"배열의 인덱스를 조정해서 푼 문제풀이 MissingInteger123456789101112131415161718192021222324252627282930313233import java.util.*;class Solution { public int solution(int[] A) { // write your code in Java SE 8 Set&lt;Integer&gt; mark = new HashSet&lt;&gt;(); int N=1; for(int i=0; i&lt;A.length; i++){ mark.add(A[i]); } List&lt;Integer&gt; list = new ArrayList(mark); Collections.sort(list); if(A.length == list.size() ){ N = list.get(list.size()-1)+1; }else{ for(int j=0; j&lt;list.size(); j++){ if(list.get(j) != j+1 &amp;&amp; list.get(j)&gt;0){ N = j+1; break; } } } return N; } 주어진 A배열의 원소들을 HashSet mark에 담아 중복을 제거한뒤,정렬된 list 객체에 담는다. 정렬된 list객체의 size와 A의 length를 비교하여 빠진 원소가 있는지 판별하고 빠진원소가 있을 경우에는배열내 가장 큰원소에 1을 더해 리턴값을 산출. 빠진 원소가 없을 경우에는 for문을 통해최대값을 찾고, 최대값+1을 리턴하는 알고리즘으로 만들었었다. 이번건 좀 어려웠다. A배열 원소의 범위가 너무 넓어서 생각해서 풀기에는 예외적인 상황들이 일어날 가능성이 너무 많았고,퍼포먼스를 고려하지않고 정확성 100프로를 달성하는것도 좀어려웠다. 문제를 풀고 하루가 지나서 다른분들이 푼 결과를 참고해보니boolean 배열을 통해 문제를 해결했더라 12345678910111213141516171819202122import java.util.*;class Solution { public int solution(int[] A) { // write your code in Java SE 8 boolean checker[] = new boolean[A.length+1]; for(int i=0; i&lt;A.length; i++){ int value=A[i]; if(value&gt;0 &amp;&amp; value&lt;checker.length){ checker[value]=true; } } for(int i=1; i&lt;checker.length; i++){ if(checker[i]==false){ return i; } } return checker.length; }} boolean 값으로 이루어진 배열을 선언하고 for문을 만들었는데 A배열의 원소를 for문의 인덱스로 사용해checker배열의 원소의 값을 true 로 바꿔준다. 첫번째 for문을 통해 연속되는 A배열 원소들의 연속성을 판단할 수 있도록 checker배열을 채우는것이다.(문장이 좀 어색하네요 :() 마지막으로 나오는 for문에서는 checker배열을 순서대로 판별해true값이 아닌 인덱스를 반환하는 알고리즘이다. 세번째 예시 int A[] = { -1, -3 } 이 경우에는 첫번째 for문에서 true가 되는 과정이 없다.그래서 boolean 배열의 상태를 나타내보면 value false false false index 0 1 2 이렇게 boolean 배열의 초기값 false로만 이루어진 상태이기때문에두번째 for문의 초기값 int i = 1 에서 1 이 리턴되는 알고리즘이다.","link":"/2018/05/19/18.05.19 MissingInteger/"},{"title":"MaxCounters","text":"curMax값을 할당한 이후 increase()연산을 수행하면 해결되는 문제였다. 문제를 이해하는데 시간이 점점 많이 걸리고있다. 영어로 쓰여있는것도 있지만 예제 먼저 보고 문제의 의미를 알려고 하다보니예외적인 상황이나 리턴값을 다르게 하는경우는 잘못 대처하는 실수를 종종 해서 다시 짜는 경우도 있다. 주의해야겠다. 123456789101112131415161718192021222324class Solution { public int[] solution(int N, int[] A) { // write your code in Java SE 8 int B[] = new int [N]; int counter = 0; for(int i=0; i&lt;B.length; i++){ B[i] = 0; } for(int i=0 ; i&lt;A.length ; i++){ if(A[i]==N+1){ for(int j=0; j&lt;B.length; j++){ B[j] = counter; } } else { B[A[i]-1] ++; counter = Math.max(B[A[i]-1],counter); } } return B; }} 내가 푼 방식은A[i]가 N+1이 아닐 경우 0으로 초기화된 배열의 원소를 1증가 시키고0으로 초기화된 counter 변수와 1증가된 원소를 비교해 counter를 갱신시키는 것이었다. A[i]가 N+1에 해당하는 원소일 경우배열의 모든 원소를 위에서 갱신된 counter변수로 바꾸는것으로 문제를 풀었다. 점수는 정확도 100%에 퍼포먼스가 60% 였다.배열의 모든수가 maxcounter일 경우 B배열을 counter값으로 채우는 과정에서TIMEOUTERROR가 났다. 문제가 된 부분은 maxcounter인 N+1에 걸릴 경우인데이걸 해결하기 위해서는 현재 B배열의 최댓값 설정 (curMax)해두고for문이 끝나고 난뒤의 마지막 과정에서 B배열의 원소중 저장된 최댓값(curMax)보다 작은 값들을curMax값으로 바꿔주면 되는 방식이다. 처음 이 방식을 접했을때는 마지막의 curMax값 할당과정을 수행하게되면“그전의 연산들 (예제에서는 6이후에 나오는 1,4,4가 해당한다)을 수행한것 까지도 curMax값으로 바뀌지 않나?” 라고 생각했는데 else부분에서 curMax값보다 작은 원소들은curMax값을 할당한 이후 increase()연산을 수행하면 해결되는 문제였다. 100% 코드","link":"/2018/05/23/18.05.23 MaxCounters/"},{"title":"CountDiv","text":"floor() 몫 구하기 CountDiv (50%) 123456789101112class Solution { public int solution(int A, int B, int K) { int count=0; for(int i=A; i&lt;=B; i++){ if(i % K == 0){ count++; } } return count; }} 문제를 간단히 요약해보자면A와 B 두 정수 사이에 K로 나누어 떨어지는 숫자의 갯수를 구하는 문제였다. worst-case time이 O(1) 으로 되어있어서처음에는 너무 어렵게 생각한것같다. 지금봐도 말도안되는 방식으로 알고리즘을 짰는데시간 다 쓰더라도 좀더 신경써서 풀어봐야겠다. 12345678910class Solution { public int solution(int A, int B, int K) { // write your code in Java SE 8 int result = B/K + 1; if(A != 0){ result -= ((A-1)/K + 1); } return result; }} 풀이과정은 정말 간단하게 풀수있었다. 문제를 다시한번 생각해보면 결국 0에서 B까지 K로 나누어 떨어지는 갯수에서0부터 A까지의 갯수를 뺀다고 생각하면되지만, 0에서 B까지의 과정을 생각해볼때 0과 A가 포함되어있다.그러므로 A!=0에서 result의 값에 포함되는 0과 A값을 빼주기 위해if문과 연산을 넣은 알고리즘이다.","link":"/2018/08/23/18.08.24 CountDiv/"},{"title":"Picking Numbers","text":"값 갱신을 이용한 문제풀이 📝 Picking Numbers (20.0) 주어진 리스트 a의 원소들로 구성할 수 있는 서브 리스트들 중 리스트 각각의 모든 원소들이 뺄셈을했을때의 절대값이 모두 1보다 작거나 같은 조건을 만족하는 서브 리스트의 사이즈를 구하는것이였다. 고민끝에 풀이를 보게 됐는데 처음 보는 형태의 이중 for문이 쓰여서 당황했다. 💡 풀이 1234567891011121314151617181920212223public static int pickingNumbers(List&lt;Integer&gt; a) { Collections.sort(a); int highestCount = 0; for(int i=0; i&lt;a.size(); i++){ int currentCount = 0; for(int j=0; j&lt;=i; j++){ if(Math.abs(a.get(i)-a.get(j)) &lt;=1){ currentCount++; if(currentCount &gt; highestCount){ highestCount = currentCount; } } } } return highestCount; } 정렬된 리스트 a에서 순서대로 절댓값 비교를 하게 되는데, 자기 자신보다 작거나 같은수까지의 비교를 통해 (j=0부터 i까지의 조건으로 만들었다.) cuurentCount 변수를 카운팅한후 highestCount 변수에 저장하는 것으로 위 조건을 만족하는지 판별한다. 조건을 만족하는 경우 정렬된 리스트에서 currentCount값이 순차적으로 커지고 이 값을 highestCount값에 갱신하여 이루어지는것이다. 소스코드를 참고했을때는 처음보는 이중 for문이라 해석이 어려웠는데 알고나니 굉장히 정교하게 짜여진 풀이방법 이었다. 블로그에 써놓고 자주 이용해볼만큼 😅","link":"/2018/12/22/18.12.23 Picking Numbers/"},{"title":"데이터베이스 삽질기","text":"데이터베이스 삽질기 ✒️ 개요 올해 1월쯤부터 DUNPIC.NET의 프론트 엔드 부분을 MDB로 전환해가면서 vscode를 접하고 백엔드 부분도 손보는 작업을 계속하고 있었다. 기존의 코드를 복사 붙여넣기하고 틀린 부분이나, 오류가 나는 부분들을 손보고 어느 정도 완성된 시점에 배포를 시작했는데, 가장 중요한 메뉴인 마법부여 기능에 문제가 있어서 JPA 인터페이스에 작성된 쿼리를 손보면서 많은 삽질을 했었기 때문에 기록해보려고 한다. 💣 헤맸던 점 먼저 내가 원했던 결과를 화면으로 올려보자면 ![결과](/images/JPA_쿼리_삽질기/result.png) 위와 같이 선택한 옵션에 수치가 높은 순서대로 정렬된후, 같은 수치의 카드가 존재 할 경우 옵션의 수가 많은쪽을 위에 표시하는 결과를 뽑아내고 싶었다. 여기서 가장 힘들었던 점은 A와 B카드가 있을때 처음 정렬 즉 수치를 기반으로한 첫 정렬이 수행된 이후 표시되는 옵션이 다른 문제가 있었다. 사진으로 표시해보자면 다음과 같았다. ![예시1](/images/JPA_쿼리_삽질기/예시1.png) 위와같은 조건일때 선택한 옵션이 아닌 왼쪽카드의 힘+50이 비교되어 정렬되는 문제였다. 이 문제는 테이블 자체가 ![relation](/images/JPA_쿼리_삽질기/relation.png) Card 테이블의 id값으로 판별되는 각각의 항목에 대해 Option 테이블에서 항목마다 효과를 적어주는 방식으로 설계한 구조적인 문제를 간과하여 서브쿼리에서 산출된 id값으로 메인쿼리를 실행할기 때문에 복수의 옵션을 가지고있는 항목의 경우 테이블에 차지하고있는 첫번째 effect의 value가 집계되어 정렬되는 문제였다. ❓ 시도했던 방법들 첫번째 방법으로는 메인 쿼리의 effect컬럼 조건을 고정시키는 방식으로 시도해봤지만, 다수의 옵션을 가지고있는 카드들이 고정된 하나의 effect컬럼만 결과값으로 갖게되기 때문에, 복수의 효과를 가지고있는 카드들을 알수 없게되었다. 두번째 방법으로는 옵션의 상위 선택지인 옵션그룹을 조건절에 넣어보는 것 이었지만, 다른 옵션그룹을 갖는 카드들도 상당수이기 때문에 기각되었다. 세번째 방법으로 서브쿼리의 조건에서 effect 컬럼을 먼저 정렬한뒤 메인쿼리를 실행하는 방법으로 해결했으나 in 으로 접하게되는 메인과 서브쿼리의 부분에서 서브쿼리에서 산출된 순서대로 메인쿼리가 작동하지않는 문제가 발생했다. 구글링과 학부생시절에 공부했던 데이터베이스 책을 뒤져 rownum을 활용해 처리해야한다는 정보를 접했는데, 이해하기가 너무 어려웠다. 이미 배포를 하고있는 시점에서 최대한 문제를 빠르게 해결하고 싶어 이번 문제는 서버단에서 처리하는 방법을 이용했다. 한개의 문장으로 처리되는 기존의 SQL을 서브쿼리와 메인쿼리를 두개의 부분으로 나눠 다음과 같이 처리했다. 123456789List&lt;Result&gt; subquery = resultDAO.findBySubquery(part, effect);List&lt;Result&gt; main = new ArrayList&lt;&gt;();for(int i=0; i&lt;subquery.size(); i++){ int id = subquery.get(i).getId(); List&lt;Result&gt; fetch = resultDAO.findByIdInJoinTable(id); main.addAll(fetch);} 서브쿼리의 결과(id)들을 for문을 통해 순서대로 받아와서 findByIdInJoinTable(id)의 매개변수로 활용, 조인테이블에서의 결과를 비어있는 리스트 main에 저장한뒤 return 하는 방법으로 원하는 결과 화면을 만들어 낼 수 있었다.","link":"/2019/02/20/19.02.21 데이터베이스 삽질기/"},{"title":"취업을 했다","text":"취업 후기 ✒️ 개요 블로그를 3월 한달간 방치했는데 독학사 이후 본격적인 구직활동에 전념하느라 시간이 없었다는 핑계를 대며 글을 써보려고 한다. 작년 연말 아쉽게 놓친 구인공고를 올해 상반기에 다시보게 되서 서류지원을 했는데 통과. 운이 좋았던것같다. 이후 2월 14일 강남 비트 컴퓨터에서 오프라인 코딩 테스트를 치뤘다. 오프라인 코딩 테스트는 처음이었는데 내가 본 시험은 올 상반기 채용과정 1회차 코딩 테스트였다. 2회차, 3회차 시험 문제를 구해보니 다행히 1회차가 굉장히 쉽게 나온덕에 코딩 테스트는 통과했다. 이후 3월초에 1차 면접과 마지막 CTO면접을 준비하며 3월을 보내면서 느낀점이나 생각들을 잊어버리지 않기 위해 포스팅을 해본다. ⏳ 코딩 테스트 코딩 테스트는 오프라인으로 강남에서 치뤘다. 오프라인 코딩 테스트라서 그런지 다행히 오후 시간대에 시작해 지옥철을 경험하진 않아 다행이었다. 코딩 테스트 준비는 해커랭크에서 제공되는 문제들을 풀어보기도하고, 한빛 미디어에서 출판한 TopCoder 탑코더 알고리즘 트레이닝으로 공부하며 준비했었다. 운좋게도 구현에 관한 문제가 여러개 출제되서 해커랭크의 구현파트를 많이 연습한 덕에 코딩테스트는 잘 치를수 있었던것 같다. 면접 준비를 핑계로 한동안 소홀히 했었는데 코딩테스트를 준비할때는 하루에 2-3문제 정도를 자기전에 꼭 풀어보며 잤었다. 해커랭크의 profile에서 날짜별 submission을 면접도 끝났으니 다시 칸을 채워야겠다…💦 위처럼 표로 확인할 수 있기 때문에 동기부여도 되며 공부 할 수 있으니 추천. ⭐️ 1차 면접 사실 1차 면접은 본격적인 구직활동을 시작한 이래로 처음 접하게 된 면접이었기 때문에 굉장히 많이 떨었다. 아마 면접때 뿐만 아니라, 면접을 앞둔 순간마저도 떨고 있었던것 같다. 면접 준비는 예상 질문지를 작성해보거나 면접 후기를 검색해보며 준비했고, 1차 면접을 통과할수 있었던건 이번 채용과정에 참여하는 지원자들이 있지 않을까라는 생각에 접하게된 오픈 채팅방이 굉장히 유용하게 작용한것 같다. 나보다 먼저 면접을 본 지원자들에게 면접에 대한 질문이나 정보들은 접할 수는 없었지만 면접장의 분위기를 미리 알 수 있다는 점이 결정적으로 작용했던것 같다. 앞서말한 면접 질문 예상이나 자기소개 준비등은 아래 링크를 참고했다. 주니어 개발자 채용 정보 1차 면접을 돌이켜보면 준비한 질문을 대답 못하는 경우가 있어 아쉬움이 남았다. 준비한 대답을 말로 설명한다는게 생각보다 쉽지 않기 때문에 이부분에 유의하며 이미 알고있는 개념을 말로 표현해보며 연습해보는것이 좋을것 같다. 🌟 2차 CTO 면접 2차 면접에서 가장 크게 당황했던 점은 준비했던 1분 자기소개를 회사에 들어와 발휘하게될 수 있는 장점을 위주로 말해보라고 하셔서 굉장히 당황했었다. 다행히 예전부터 자기소개서를 정리하며 질문에 대한 대답이나 면접 준비를 하며 준비했던 대답의 내용들을 큰 단위로도 기억해놓은 상태였기 때문에 다행히 애드립으로 넘어갈 수 있었다. 그때 자기소개를 뭐라고 했는지는 정확히 기억이 나질 않는다 😓 2차 면접을 돌이켜보면 1차 면접때 나온 기술면접 질문들보다는 난이도는 낮았지만 자신이 갖고있는 웹프로그머에 관한 생각을 묻는 질문들이 많아 대답을 하고도 잘했는지 못했는지 판단하기가 어려워서 반신반의하며 면접결과를 기다렸던 기억이 난다. 2차 면접에 관한 준비는 1차와 마찬가지로 면접 질문들을 정리해보면서 시간을 보냈지만 이것보다는 내가 했던 프로젝트나, 이루었던 것에 관한 생각들을 정리해보며 많은 시간을 보냈던것이 주요했던것 같다. 2차 면접에 관한 준비는 주위에서 들리는 “거기까지 갔으면 된거 아냐?”라는 말에 현혹되지 않고 (사실 이말을 듣는게 너무 부담스러웠다.) 어떤 질문이 나올까 생각해보며 머릿속을 정리했던것으로 했던것 같다. 👏 합격통보 2차 면접을 치른 후 4월초 발표가 나올것이다라는 말을 듣고 정말 간절하게 기다려왔었다. 2차 면접 결과를 앞서 말했듯 잘본 면접이라는 기색이나 분위기를 알수가 없었기 때문에 멍한 상태로 몇일을 보내고 있던 중에 다행히 예정보다 일찍 합격통보를 받고 몇일전 신입 오리엔테이션에 다녀왔다. 앞으로 몇개월간의 신입사원 교육을 거쳐 본사에 입사하게 되는데 받게될 신입사원 교육에서 지금 느끼는 마음처럼 교육에 열의를 갖고 임하고 싶은 마음이다. 작년에 학교를 졸업하고 독학사를 합격후 올해 생각보다 좋은 기회로 취업을 하게 되었는데 졸업 후 세웠던 계획대로 일이 잘풀리게 되서 기쁜 심정이다. 덕분에 자존감도 올라간것 같기도 하고 😄","link":"/2019/04/08/19.04.09 취업을 했다/"},{"title":"자바 스크립트 - 변수","text":"🔍 자바스크립트 소개 변수 선언의 3가지 방법.var변수의 선언, 값의 초기화. let블록 범위 지역 변수 선언, 값의 초기화. const블록 범위 읽기 전용 상수 선언. 클로저(closure) 내부함수가 외부함수의 context에 접근할 수 있는 것을 가르킨다. 12345678910function outter(){ var title = 'test'; function inner(){ console.log(title); } inner();}outter(); 위 예제에서 내부함수(inner)가 외부함수(outter)의 지역변수 title에 접근한것과 같다. 외부함수의 지역변수를 사용하는 내부함수가 소멸될때까지 소멸되지 않는 특성을 말한다. 12345678function outter(){ var title = 'test'; return function(){ alert(title); }}inner = outter();inner(); outter의 호출결과인 익명함수의 결과가 변수 inner에 담긴후, inner()의 실행에서 title변수에 담긴 값이 출력되는 결과가 나온다. 이것은 outter()이 아닌 inner()의 호출 이후 소멸된다는것을 의미한다. 12345678910var arr = [];for(var i=0; i&lt;5; i++){ arr[i] = function(){ console.log(i); }}for(var index in arr){ console.log(arr[index]());} 위 예제는 클로저에서 자주 일어나는 실수로모두 5가 리턴된다. 이것은 i가 외부함수의 변수가 아니기 때문에아래와 같이 123456789101112var arr = []for(var i=0; i&lt;5; i++){ arr[i] = function(id){ return function(){ return id; } }(i);}for(var index in arr){ console.log(arr[index]());} 내부함수가 외부함수의 지역변수 id를 참조해 리턴되는 형태를 띄기 때문에 0부터 5의 값을 리턴한다.","link":"/2019/04/23/19.04.23 변수/"},{"title":"자바 스크립트 문법","text":"🔍 자바스크립트 문법 1. 느슨한 타입체크- 자바스크립트의 느슨한 타입체크는 다른 언어들의 강력한 타입체크 방식에 비해 오류찾기의 어려움이 아닌 자유로움 이라는 점에 집중되어 설계 되었다. - 그렇기 때문에 복잡한 클래스 계층을 구성할 필요없으며 타입 캐스팅에 소모되는시간도 줄일 수 있다. # 2. 객체 리터럴(Literal) 표기법1234567891011var o = {};var o = { a: \"foo\", b: 42, c: {} };var a = \"foo\", b = 42, c = {};var o = { a: a, b: b, c: c };var o = { property: function ([parameters]) {}, get property() {}, set property(value) {},}; - 단순히 필요한 요소를 열거하는 방식으로 객체를 생성하는 방법으로더 짧고 직관적이며 객체를 생성하기 용이한점등의 장점을 갖는다. 3. 프로토타입에 의한 상속- 자바스크립트에서 클래스 대신 객체를 복사하여 새로운 객체를 생성하는 방법. prototype 속성( prototype Object ) - 자신으로부터 만들어질 객체들에 대한 속성 객체 멤버인 proto속성이 참조하는 숨은 링크( Prototype Link ) - 상위에서 물려받은 객체의 프로토타입에 대한 정보 4. 전역변수를 근간으로 하는 문제 변수 이름의 충돌 가능성 변경에 취약한 문제 모든 함수에서 전역변수의 값이 변경될 수 있어 신뢰성 보장이 어렵다. ✒️ 자바스크립트의 문법1. 숫자(Numbers)- 다른 언어와는 달리 정수와 실수의 구분이 없다. - 작은 단위의 자료형을 사용해 오버플로우가 발생할 일이 없어 편리하다. - NaN은 Not-A-Number라는 의미로 정상적인 값이 아닐때를 나타내는 값을 말한다. NaN은 전역객체로써 존재하기에 예외상황을 가정하기위해 NaN을 판별하기 위해서는 isNaN()이라는 함수를 사용해 처리한다. 1234NaN === NaN; // false (NaN 객체는 자기자신과도 같지않다.)Number.NaN === NaN; // falseisNaN(NaN); // trueisNaN(Number.NaN); // true # 2. 문자열(Strings)- JS에서는 문자 타입이 없다. - JAVA와 같이 문자열에 관한 메소드도 존재한다. - 이스케이프 시퀀스나 \\ , 같은 문자를 문자열에 삽입해 표현할 수 있다. 3. 문장(Statements)- 웹 브라우저에서 각각의 &lt;script&gt;태그는 컴파일되어 즉시 실행되는 하나의 컴파일 단위를 말한다. - var는 함수내부에서 사용될때 함수의 private변수를 정의한다.","link":"/2019/04/24/19.04.24 자바스크립트 문법/"},{"title":"자바 스크립트 어휘 구조","text":"💬 어휘 구조 HTML의 태그나 속성이름이 대문자와 소문자가 섞여있는것과는 달리, JS에서는 모두 소문자 로 처리한다. 💲 타입, 값, 변수 타입- 원시타입 (primitive type) : 숫자, 텍스트의 나열, 불리언 진리값, null과 undefined- 객체타입 (object type) : 원시타입 외의 값은 모두 객체이다. 값- 클래스는 객체 타입의 하위 타입으로 생각 할 수 있다. 자바스크립트 인터프리터는 메모리 관리르 위해 자동으로 기비지 컬렉션을 수행한다.객체에 더이상 접근 할 수 없을때 인터프리터는 자동으로 메모리에서 해제한다. 변수- 타입이 정해져있지 않아 같은 변수에 다른 타입의 값을 할당할 수 있다.- 어휘 유효범위(scope)를 사용한다. 📕 Math Method description .pow(2,53) 2의 53승 .PI 원주율 .E 자연 로그 상수 .sin 삼각함수 (.cos, .atan) Math.log(100)/Math.LN10 밑이 10인 로그 100 .exp(3) Math.E의 3 거듭제곱 # ⚠️ 이진 부동소수점과 반올림 오류 JS의 분수는 이진 표현법으로 표현되어 10진수 분수와 같은 수치들은 정확하게 표현할 수 없다. 12345var x = .3 - .2; // 0.3 - 0.2var y = .2 - .1;x == y // falsex == .1 // falsey == .1 // true 이진 부동소수점 숫자를 사용하기때문에 값들의 비교문에서 문제가 발생한다.# 🔍 패턴 매칭 문자열과 RegExp 객체는 모두 패턴 매칭과 ‘검색 후 바꾸기’ 기능을 수행하는 메서드를 가지고 있다. 123/^HTML/ // `HTML`로 시작하는 문자열/[1-9][0-9]*/ // 0 아닌 숫자로 시작하는 숫자/\\bjavascript\\b/i // 대소문자 구별 없이 javascript와 일치하는 문자열 🔮 전역 객체 최상위 코드(함수의 일부가 아닌 코드) 에서는 this 키워드를 통해 전역 객체를 참조 할 수 있다. 1var global = this; // 전역 객체를 참조하는 변수를 정의 🔭 변수의 유효범위 같은 이름을 갖는 경우, 함수 내부에서 지역 변수는 전역 변수에 우선한다.지역 변수 혹은 함수 매개변수를 전역 변수와 같은 이름으로 선언하면, 전역 변수는 감춰 버리게된다. 123456var scope = \"global\";function checkscope(){ var scope = \"local\"; return scope; //전역 변수가 아닌 지역변수를 반환한다.}checkscope(); // return \"local\" # 함수 정의는 중첩 될 수 있다. 각 함수에는 자신만의 유효범위가 있다. 따라서 아래와 같이 유효범위가 여러단계로 중첩 될수 있다. 12345678910111213var scope = \"global\";function checkscope() { var scope = \"local\"; function nested() { var scope = \"nested\"; return scope; } return nested();}checkscope(); // \"nested scope\" ⚓️ 함수 유효범위와 끌어올림 (hoisting) 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는것이다. 즉, 변수가 함수내에서 정의 되었을 경우선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우는 전역 컨텍스트의 최상위로 변경됩니다. 말 그대로 선언 혹은 정의의 위치가 끌어올려 지는것이다. 123456function showName() { console.log(\"First Name : \" + name); var name = \"Ford\"; console.log(\"Last Name : \" + name);}showName(); 이 코드는 자바스크립트 엔진에 의해 다음과 같이 해석된다. 123456function showName() { var name; // ⚓️ Hoist! console.log(\"First name : \" + name); name = \"Ford\"; console.log(\"Last Name : \" + name);} - JavaScript Variable Scope and Hoisting Explained By Richard Bovell 📝 ⛓ 유효범위 체인","link":"/2019/04/26/19.04.26 자바스크립트의 어휘구조/"},{"title":"InetAddress 클래스","text":"🌏 네트워크와 소켓 이해 🌏 네트워크와 소켓 이해📡 DNS( Domain Name System) DNS 또는 Domain Name System은 사람이 읽을 수 있는 도메인 이름을 머신이 읽을 수 있는 IP 주소(예: 192.0.2.44)로 변환합니다. 12# nslookup (/usr/bin/nslookup)- 도메인 네임 서버의 정보를 쿼리하기 위해 사용. 📍 InetAddress This class represents an Internet Protocol (IP) address. Method description static InetAddress getLocalHost() 로컬호스트의 주소 반환 getHostName() 호스트 이름을 문자열로 반환 getHostAddress() 호스트 IP 반환 getAddress() InetAddress 객체의 IP주소를 반환 💻 NSLookup in JAVA Scanner와 nextLine()을 도메인을 입력받는다. 입력받은 도메인의 IP주소를 출력. “exit”일 경우 프로그램 종료. InetAddress의 static 메서드 getAllByName(String host)를 사용. getAllByName() : “www.google.com&quot; 같은 호스트를 입력받아 해당 주소에서 모든 IP를 가져오는 메서드","link":"/2019/04/28/19.04.28 InetAddress 클래스/"},{"title":"InputStream 과 OutputStream","text":"🌊 InputStream 과 OutputStream 단일 방향으로 흘러가는 데이터의 흐름을 표현하는것으로 Stream이라고한다. 입력 스트림의 출발지 (키보드, 파일) 에서 출력 스트림의 도착지 (모니터, 파일, 프로그램) 의 관계를 띈다. InputStream Method descrption read() inputstream 으로부터 데이터의 byte를 읽어낸다 read(byte b[]) inputstream과 buffer 배열 b 로부터 byte로 이루어진 데이터를 읽어낸다 OutputStream Method descrption flush() 버퍼에 잔류하는 모든 바이트를 출력한다 write(byte b[]) outputstream이 갖고있는 바이트 배열 b를 모두 write 한다 소켓 프로그래밍에서의 I/O Stream1234567891011121314151617181920212223InputStream input = socket.getInputStream();OutputStream output = socket.getOutputStream();while(true) { //5. 데이터 읽기 byte buffer[] = new byte[256]; int readByteCount = input.read(buffer);//blocking. if(readByteCount == -1) { // 클라이언트 정상종료 한 경우 System.out.println(\"[server] closed by client.\"); break; } String data = new String(buffer, 0, readByteCount, \"utf-8\"); System.out.println(\"[server] received \" + data); //6. 데이터 쓰기 output.write(data.getBytes(\"utf-8\")); } 소켓 프로그래밍에서의 IOStream은 생성한 소켓으로부터 accept() 이후 연결이 되면각각의 stream객체를 얻게되고 read/write Method를 사용해 데이터 통신이 이루어진다.","link":"/2019/04/28/19.04.28 InputStream 과 OutputStream/"},{"title":"소켓 프로그래밍","text":"🌏 네트워크와 소켓 이해 🔌 소켓 TCP/IP 프로토콜의 프로그래머 인터페이스를 제공해주는것. 3가지 과정으로 사용 소켓 생성 OPEN 소켓을 통한 송/수신 소켓 소멸 CLOSE # 💻 Socket 프로그래밍1int sockfd = socket ( PF_INET, SOCK_STREAM, IPPROTO_TCP ); domain 프로토콜 체계 (Protocol Family) 의미 PF_INET IPv4 인터넷 프로토콜 PF_INET6 IPv6 인터넷 프로토콜 PF_LOCAL 로컬 통신을 위한 UNIX 프로토콜 체계 PF_PACKET Low Level 소켓을 위한 프로토콜 체계 PF_IPX IPX 노벨 프로토콜 체계 type 📞 SOCK_STREAM ( 전화 ) ServerSocket Socket - TCP 통신소켓이다.- stream방식의 연결지향 소켓 생성.- 양방향 통신- byte를 주고받는 가변길이 stream이다.- 전달된 모든 데이터는 무결성 이 보장된다. 🎥 SOCK_DATAGRAM ( 스트리밍 ) DatagramSocket - UDP 통신 소켓이다.- datagram 방식의 비동기 소켓을 생성.- 양방향 통신- 고정길이의 메시지를 사용- 신뢰성 보장 ❌ 📍 포트번호- 각각의 소켓을 구분 할 때 사용하는 것 아파트(host)에 사는 사람(process)에게 편지(data)를 보낼때 동(IP)과 호(Port)를 봉투(Packet)에 기입해야 한다. 포트의 중복은 불가능하다.하지만, 같은 UDP 포트와 TCP 포트는 중복하여 사용 가능하다.","link":"/2019/04/28/19.04.28 소켓 프로그래밍/"},{"title":"TCP 소켓 프로그래밍","text":"🌏 TCP 소켓 프로그래밍 TCP (Transmission Control Protocol) 연결 지향 서비스 전이중(Full-Duplex) Socket 생성 Setsockopt- 필수적인 과정은 아니지만 주소와 포트번호의 재활용이 이루어질 수 있다. 또한, 주소가 이미 사용중인 경우를 피할 수 있다. Bind()- 소켓의 생성이후 소켓의 IP주소와 포트번호를 특정짓는다. Listen() ServerSocket- 소켓의 상태를 클라이언트와의 연결을 위한 대기상태 놓는다.- 백로그는 이미 들어온 연결외에 동시연결을 시도하는 최대 클라이언트의 수를 의미한다. Accept() ServerSocket- Connect()에서 받은 정보를 통해 요청한 클라이언트와의 연결을 위한 소켓을 생성한다. Send()- Write()로 추가적인 데이터를 보낸다. 비트 교육 과정에서의 TCP 소켓 프로그래밍 절차는 Scanner를 통해 입력받는 과정에서 Listen() 상태를 표현했고InputStream / OutputStream 을 받아오고, 데이터를 읽고 보내는 과정 전체를 Send() 로 설계했다. Client 쪽에서는 Connect() 에서 서버 연결 후 InputStream / OutputStream 을 통해 데이터를 읽고 쓰는 과정을 진행한다. TCP Server/Client 코드","link":"/2019/04/30/19.04.30 TCP 소켓 프로그래밍/"},{"title":"자바 스크립트 - 표현식과 연산자","text":"📝 표현식과 연산자 💲 기본 표현식 this this는 상수가 아니고 프로그램 안에서 위치에 따라 각기 다른 값으로 평가된다.this 키워드는 객체 지향 프로그래밍에서 주로 사용된다.메서드의 본문 안에서 this는 메서드를 호출한 객체 자기 자신으로 여겨진다. 💭 함수 정의 표현식 함수 정의 표현식은 ‘함수 리터럴’이라 할 수 있다. 1var square = function(x){return x*x;} 📱 연산자 OP description return delete 프로퍼티를 제거 boolean typeof 피연산자의 타입 문자열 instanceof 객체 타입 확인 boolean ?: 조건부 연산자 타입 무방 🔍 비트 단위 연산자 비트 단위 AND(&amp;) - 비교하는 비트가 모두 1이라면 1반환 비트 단위 OR(|) - 비교하는 위치에 비트가 설정 되어 있으면 해당 비트로 설정 비트 단위 XOR(^) - 비교하는 위치에 비트중 하나가 true이지만 둘다 true는 아닐때 결과가 true가 된다 비트 단위 NOT(~) - 모든 비트를 반전 레프트 시프트(&lt;&lt;) - 지정한 수만큼 비트 전체를 왼쪽으로 이동 라이트 시프트(&gt;&gt;) - 지정한 수만큼 비트 전체를 오른쪽으로 이동 0으로 채우면서 오른쪽으로 이동(&gt;&gt;&gt;)- 지정한 수만큼 비트를 전부 오른쪽으로 이동 새로운 비트는 전부 0이 된다. ❓ 동치와 부등치 연산자 =(할당), ==(동치), ===(일치) = : 할당 == : 동등한 관계, 타입변환을 시도한 후에 비교를 다시 하게된다 === : 좀더 엄한 규칙, 같은 참조를 하고 있는 경우에 true in 연산자 좌변의 속성을 우변이 포함 하고 있을때. 12345678var point = { x:1, y:1};\"x\" in point // true\"z\" in point // false\"toString\" in point // true : 상속된 프로퍼티var data = [7,8,9];\"0\" in data // true : 배열에 0번째 원소가 있어서1 in data // true : 배열에 1번째 원소가 있기 때문에3 in data // false instanceof 연산자 피연산자의 상위클래스에 객체가 속하는지 판단 123var date = new Date();d instanceof Date; // trued instanceof Object; // true eval() 평가 표현식 문자열 (로 이루어진 코드) 을 자바스크립트로 해석하고 결과를 값으로 출력하는 기능 1234eval(\"3+2\") // =&gt; 5var d;eval(\"d = new Date;\"); // =&gt; Mon Apr 29 2019 20:40:10 GMT+0900 (한국 표준시) {} 1✔️ 전달 하려는 문자열이 독립된 스크립트로서 문제가 없을때 사용하는것에 유의하여야 한다. ?: 조건부 연산자1x &gt; 0 ? x : -x // x의 절대 값을 구한다. 12greeting = \"hello \" + (username ? username : \"there\");// 'username'이 true 즉, username에 변수가 정의되어 있지않다면 \"there\"를 사용하는것 문장 typeof 연산자12(type value == \"string\") ? \"'\" + value \"'\" : value;// value의 타입이 문자열이라면 문자열 'value'를 반환 # delete 연산자12345678var o = {x:1, y:2};delete o.x; // return true\"x\" in o; // falsevar array = [1,2,3];delete a[2];2 in a; // falsea.length; // ✔️ 3 배열의 길이는 변하지 않는다.","link":"/2019/04/29/19.04.29 표현식과 연산자/"},{"title":"Maven","text":"🐦Maven 🔧 의존성 관리 Java 기반의 프로젝트 빌드, 컴파일을 수행하는 빌드 도구이다.빌드시 테스트를 병행 수행 하거나 서버 측 deploy 자원을 관리 할 수 있다.Maven의 주된 목표는 최단시간내에 개발한것의 전체 상태를 이해 할 수 있게 하는것입니다.- 📝 What is Maven? 🔧 의존성 관리 /pom.xml 1234567&lt;dependency&gt; &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt; &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; ...&lt;/dependency&gt; properties - 특정 값을 배포 환경에 따라 값을 다르게 하기 위해서 다음과 같이 치환하고자 하는 변수를 추가한다.1234&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 빌드시 소스코드 인코딩 타입 지정 --&gt;&lt;/properties&gt; 빌드된 .jar 에서는 루트 디렉토리에 생성한 webapp을 포함하지 않은채로 빌드되지 않는다. new ➡️ 📁 SourceFolder (“/resources”) 📁 webapp ➡️ 📁 SourceFolder (“/resources”) 📁 ROOT project ➡️ 🔧 Properties ➡️ Java Build Path의 include 확인 📄 pom.xml에 &lt;resources&gt;추가 ✔️ (Optional) DOCUMENT_ROOT path를 절대경로로 바꾸어 주는 코드를 작성해야한다. ❗️ 클래스 로딩시 실행되는 static{}를 만들어 절대경로를 바꿔주자 1234567891011121314151617181920static { // this가 로딩됐을때 실행되는 부분 try { documentRoot = new File(RequestHandler.class. getProtectionDomain(). getCodeSource(). getLocation(). toURI()). getPath(); documentRoot += \"/webapp\"; System.out.println(\"----&gt;\" + documentRoot); } catch (URISyntaxException e) { // TODO Auto-generated catch block e.printStackTrace(); }}","link":"/2019/05/01/19.05.01 Maven/"},{"title":"자바 스크립트 - 객체","text":"6장 객체 객체 자바 스크립트 객체는 객체가 가진 고유 프로퍼티를 유지하는 것 외에 프로토타입이라고 하는 다른 객체의프로퍼티를 상속 받는다. 객체의 메서드 들은 일반적으로 상속 받은 프로퍼티이고, 이를 프로토타입 상속 이라고 한다. 프로토타입 자바 스크립트에서 객체의 생성시 주어지는 Constructor를 선언할때마다 new를 사용하며Prototype Object 도 같이 생성된다.이렇게 생성된 prototype object를 통해 속성을 컨트롤 하는것으로,생성된 객체는 __proto__ 속성를 통해 함수로 선언된 객체의 프로퍼티를 참조하는것이다. 123456789function Person() {}Person.prototype.eyes = 2;Person.prototype.nose = 1;var kim = new Person();var park = new Person():console.log(kim.eyes); // =&gt; 2 Object.create() 임의의 프로토타입으로 새 객체(상속자 객체)를 만드는데 유용하게 사용된다. 1234567891011function inherit(p){ if(p == null) throws TypeError(); if(Object.create()) return Object.create(p); var t = typeof p; function f(){}; f.prototype = p; return new f();}//프로토 타입 객체 p의 속성을 상속받아 새롭게 생성된 객체를 반환한다. 연관 배열로서의 객체1234object.propertyobject.[\"property\"]//✔️인덱스가 아닌 문자열을 인덱스로 갖는 배열에 접근하는 형태 =&gt; `Hash` `Map` `diectionary` 배열 표기법 자바스크립트에서의 연관 배열 사용은 객체.프로퍼티로 이루어진 접근방식과는 달리객체[“property_name”]과 같이 프로퍼티의 이름을 미리 알아야 한다는점보다 유연하다. 👪 상속 ✔️ 프로토타입 객체와의 관계를 유의하자. 123456789var o = {};o.x = 1;var p = inherit(o);p.y = 2;var q = inherit(p);q.z = 3;var s = q.toString();q.x + q.y; // return 3 q의 프로퍼티 x와 y는 각각 o와 p에서 상속받았다. 12var len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;// book 객체와 그 프로퍼티들 값들의 무결성을 확인해 변수에 할당하는 방식 🔎 프로퍼티 검사하기 .containsKey() in hasOwnProperty() propertyIsEnumerable()# Object.keys() : iterator 처럼 키 나열 💡 프로퍼티 Getter와 Setter getter/setter로 정의된 프로퍼티는 접근자 프로퍼티 로 데이터 프로퍼티와는 다르다. 1234567var o = { data_prop : value, // 데이터 프로퍼티 get accessor_prop() { ... }, set accessor_prop(value) { ... }}; ⚛️ 프로퍼티 속성 writable : 프로퍼티 값들의 변경 가능 여부 enmerable : 프로퍼티들의 열거될 수 있는지의 여부 configurable : 속성 값의 변경 가능 여부 객체 속성class 속성 객체의 타입에 대한 정보를 담고 있는 문자열이다. 12345function classof(o){ if(o === null) return \"Null\"; if(o === undefined) return \"Undefined\"; return Object.prototype.toString.call(o).slice(8, -1);} extensible 속성 객체에 새 프로퍼티를 추가 할 수 있는지 여부를 결정한다. 여부의 질의를 하려면 Object.isExtensible() 함수에 해당 객체를 인자로 넘긴다. 📐 객체 직렬화 객체의 상태를 문자열로 변환하는 과정을 말한다. ECMAScript 5는자바스크립트 객체를 직렬화 하는 JSON.stringify() 메서드와 직렬화한문자열을 객체로 복원하는 JSON.parse() 메서드를 지원한다. toString() 메서드 호출 대상 객체의 값을 어떠한 방식으로든 문자열로 만들어 반환한다. 그렇기 때문에 많은 클래스가 고유한 방식으로 toString() 메서드를 정의하고 있다. valueOf() 메서드 toString()과 유사하지만 원시 타입 값을 필요로 하는 문맥안에서 사용될때 자동으로 호출되는 메소드이다.","link":"/2019/04/30/19.04.30 객체/"},{"title":"멀티 스레드 프로그래밍","text":"멀티 스레드 프로그래밍 멀티 스레드 프로그래밍에서의 작성 방법 java.lang.Thread- Thread 클래스의 상속을 받아 구현하기에 다른 클래스 상속이 불가능 하다는 점 java.lang.Runnable- Runnable 인터페이스를 implements 받아 사용하므로 코드의 재사용성과 일관성이 향상됨 다중처리 EchoServer","link":"/2019/05/01/19.05.01 멀티 스레드 프로그래밍/"},{"title":"채팅","text":"✉️ 채팅 프로그래밍 InputStreamReader 과 OutputStreamWriter ❓ 왜 바이트 단위로 읽어내는지? Writer InputStreamReader 과 OutputStreamWriter 👀 InputStreamReader- InputStreamReader은byte 에서 character로의 casting을 수행한다효율적인 코드 작성법 ✍️ OutputStreamWriter- OutputStreamWriter은byte단위로 write하는 outputstream을 이용해 character단위로 쓰도록 변형한다. 12345678910111213141516171819202122232425262728293031323334import java.io.*;public class StreamReaderTest { public static void main(String[] args) { if(args.length != 1) { System.out.println(\"사용법 : java StreamReaderTest file_name\"); System.exit(0); } FileInputStream fis = null; InputStreamReader isr = null; OutputStreamWriter osw = null; try { fis = new FileInputStream(args[0]); isr = new InputStreamReader(fis); osw = new OutputStreamWriter(System.out); char[] buffer = new char[512]; int readcount = 0; while((readcount = isr.read(buffer)) != -1) { osw.write(buffer, 0, readcount); } } catch(Exception ex) { System.out.println(ex); } finally { try { fis.close(); isr.close(); osw.close(); } catch(Exception e) {} } }} ❓ 왜 바이트 단위로 읽어내는지? - InputStream 에서 read()메소드의 파라미터로 올 수 있는 자료형은 byte b[] 뿐이다 - Java의 Char 와 String의 타입의 경우 Characters로 취급 되어진다. 1234이말은 Char / String를 저장하려면 char 단위로 읽고 쓰는 Reader 와 Writer를 사용해야 한다.`InputStreamReader` 과 `OutputStreamWriter`는이 문제를 해결하기 위해서 byte 단위로 데이터를 읽어 Char형태로 변화 시켜 연결 고리 역할을 하는것이다. Writer 문자 출력 스트림의 최상위 추상 클래스이다. Class description Writer 출력하는 데이터를 문자열로 취급 BufferedWriter 버퍼를 사용해 문자 단위로 출력 OutputStreamWriter 출력스트림 객체를 받아 생성","link":"/2019/05/01/19.05.01 채팅/"},{"title":"RDBMS","text":"📁 RDBMS 데이터 베이스의 특성 ORM과 JPA그리고 Hibernate 💥 ORM (Object Relational Mappin) 🌉 JPA (Java Persistence API) Hibernate 데이터 베이스 관리의 장점 데이터 베이스 관리의 단점 데이터들의 집합을 관계형으로 표현하는 것으로 행과 열의 집합으로 구성된 테이블의 묶음 형식으로 데이터를 제공한다.테이블 형식의 데이터를 조작 할 수 있는 관계 연산자를 제공한다. 데이터 베이스의 특성 실시간 접근성 (Real-tiem Accessability) 계속적인 변화 (Continuous Evolution) - 정확한 값을 유지하기위해 삽입,삭제,수정 등을 이용해 데이터를 지속적으로 갱신 할 수 있다. 동시 공유성 (Concurrent Sharing) 내용 참조 (Content Reference) - 저장한 데이터 레코드의 위치나 주소가 아닌 사용자가 요구하는 데이터의 내용, 즉 데이터 값에 따라 참조할 수 있어야 한다. 포인터 같은 주소 개념이 아니라, 검색엔진처럼 키워드 내용을 검색하는것 처럼 작동한다. ORM과 JPA그리고 Hibernate💥 ORM (Object Relational Mappin) ORM이란 객체와 DB의 테이블이 매핑을 이루는 것을 말합니다.즉 객체가 테이블이 되도록 매핑 시켜주는 것을 말합니다.ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메서드)로서 데이터를 조작할 수 있습니다. 🌉 JPA (Java Persistence API) Mybatis에서는 테이블 마다 비슷한 CRUD SQL을 계속 반복적으로 사용했었습니다.소규모라도 Mybatis로 애플리케이션을 만들어 보셨다면, DAO 개발이 매우 반복되는 작업이며, 이 작업이 매우 귀찮다는 경험을 해보았을 것입니다. 또한 테이블에 칼럼이 하나 추가된다면 이와 관련된 모든 DAO의 SQL문을 수정해야 합니다.즉 DAO와 테이블은 강한 의존성을 갖고 있습니다. 객체 모델링보다 데이터 중심 모델링(테이블 설계)을 우선시 했으며, 객체지향의 장점(추상화, 캡슐화, 정보은닉, 상속, 다형성)을 사용하지 않고 객체를 단순히 데이터 전달 목적( VO, DTO )에만 사용했기 때문입니다.- 📝 ORM과 JPA 그리고 Hibernate 그렇기 때문에 클래스 설계시 생산하는 DAO에 JPA를 상속받은 상태로 객체의 선언시 DAO의 메소드를 활용해 ORM과정을 수행하는 것이다. 코드로 표현해보자면 다음과 같다. 12345678public interface PostDAO extends JpaRepository&lt;Post, Integer&gt;{ Page&lt;Post&gt; findByCategoryId(int categoryId, Pageable pageable); @Query(\"Select p from Post p where p.push &gt;= 5\") public Page&lt;Post&gt; Push(Pageable pageable);} 위처럼 JpaRepository&lt;객체, PK&gt;의 형태로 상속받은 후 1234567891011@RequestMapping(\"/list/recommend\") public String Recommend(Model model, @RequestParam(value=\"category\", required = false, defaultValue = \"0\") int categoryId, @PageableDefault(sort = {\"id\"}, direction = Sort.Direction.DESC, size = 10) Pageable pageable) { Page&lt;Post&gt; postPage; postPage = postDAO.Push(pageable); model.addAttribute(\"postPage\", postPage); ... } 와 같이 JPA는 DAO를 통해 ORM을 거친 테이블을 postPage라는 객체에 할당하여 사용하는것을 가능하게 한다. Hibernate Boss에서 개발한 ORM 프레임워크 Hibernate는 하나부터 열까지 OR매핑을 하고자 할때 가장 좋다. 이는 완벽한 ORM솔루션을 제공하지만 쿼리에 대한 제어를 어렵게 한다. Hibernate는 애플리케이션과 데이터베이스 각각에 대한 설계에 대한 완벽한 통제가 가능한 상황에서 이상적인 솔루션이다.- 📝 Hibernate, JPA, and Mybatis Which is right for you? 데이터 베이스 관리의 장점 데이터의 일관성 및 무결성 유지 - 연관있는 상호간의 데이터가 유지되어야 하는 특성덕에 수정이나 삭제가 한곳에서만 일어날 경우 에러 발생 데이터의 중복 최소화 데이터 보안 보장 데이터 베이스 관리의 단점 운영비가 비싸다 백업 및 복구에 대한 관리가 복잡 부분적 데이터 베이스 손실이 전체 시스템을 정지","link":"/2019/05/02/19.05.02 RDBMS와 ORM/"},{"title":"Basic Queries","text":"Baisc Queries Data Migration ORDER BY About Syntax count(Attribute) restore dump hr 계정 생성 MySQL 함수 숫자형 함수 now() sysdate() DATE_FORMAT(date,format) PERIOD_DIFF() DATE_ADD CAST(Expression AS type) / CONVERT(Expression, type) Command 취소- 긴 쿼리를 작성하다가 중간에 취소해야하는 경우\\c를 붙혀주면 된다. Data Migration 📝텍스트(.txt) 파일을 읽어 테이블에 인서트하는 LOAD DATA INFILE 구문이 있다.기본 INSERT 구문을 쓰는 것보다 20배 정도 빠르다. 1MYSQL &gt; load data local infile '/home/webmaster/pet.txt' into table pet; ✔️ 한 레코드의 값들은 탭(tab)으로 구분되어야 한다.✔️ 순서는 테이블을 생성할 때의 column순서대로 되어있어야 한다. ORDER BY ❗️ order by의 기본 정렬 옵션은 ASC (오름차순)이다. About Syntax % - 여러개의 문자열 _ - 1개의 문자 count(Attribute) ❗️ Attribute가 Null값을 가진 record를 제외하고 카운팅한다. restore dump1# mysql -u root -p &lt; employees.sql hr 계정 생성 로컬 접근 계정 1create user 'hr'@'localhost' identified by 'hr'; 🔑 권한 부여 1grant all privileges on employees.* to 'hr'@'localhost'; 192.168.1.56에서 접근하는 hr 계정 1create user 'hr'@'192.168.1.56' identified by 'hr'; 🔑 권한 부여 1grant all privileges on employees.* to 'hr'@'localhost'; 🌀 Grant 테이블 reload 1flush privileges MySQL 함수숫자형 함수now()1select now(), sleep(2), now(); now() sleep(2) now() 2019-05-03 14:22:16 0 2019-05-03 14:22:16 sysdate()1select sysdate(), sleep(2), sysdate(2); sysdate() sleep(2) sysdate() 2019-05-03 14:23:03 0 2019-05-03 14:23:05.48 DATE_FORMAT(date,format)1select date_format(now(), '%Y %c월 %d일 %h시 %i분 %s초') date_format(now(), ‘%Y %c월 %d일 %h시 %i분 %s초’) 2019 5월 03일 02시 29분 25초 PERIOD_DIFF() YYMM이나 YYYMM으로 표기된 두 날짜 사이의 Month를 반환 1234SELECT concat(first_name, ' ', last_name) AS name,PERIOD_DIFF( DATE_FORMAT(CURDATE(), '%Y%m'), DATE_FORMAT(hire_date, '%Y%m') )FROM employees DATE_ADD12select first_name, hiredate, date_add(hiredate, interval 5 month); first_name hiredate date_add(hiredate, interval 5 month) Georgi 1986-06-26 1986-11-26 Bezalel 1985-11-21 1986-04-21 Parto 1986-08-28 1987-01-28 ㅡㅡㅡ ㅡㅡㅡ ㅡㅡㅡ CAST(Expression AS type) / CONVERT(Expression, type) type을 변경 하는데 유용하게 쓰이는 함수","link":"/2019/05/03/19.05.03 Basic Queries/"},{"title":"리눅스 정리","text":"💻 패키지 🌐네트워크 🌳 파일시스템 📦 실습환경에서 설치했던 패키지들 ⏲ 서버 시간 동기화 📁/etc/bashrc 🥚 파일 압축 관리 tar 🌐 네트워크 설정 🌳 리눅스 파일 시스템* [**VFS (Virtual File System)**](#vfs-virtual-file-system) * [**FHS (File Hierarchy System)**](#fhs-file-hierarchy-system) 📦 실습환경에서 설치했던 패키지들 crontab 윈도우에서의 “작업 스케줄러”와 유사하다.crontab은 특성 시간에 예약된 명령어가 수행되도록 하는 기능이다 (서버 시간 동기화에 사용) rdate 원격주소의 시간정보를 얻어와 동기화, 출력하는데 사용된다. (cron을 통해 자동으로 주기마다 실행) gcc / gcc-c++ GNU Compiler Collection 개발환경 구축을위한 컴파일러 make 프로그램 그룹을 유지하는데 필요한 유틸리티, 어느부분이 새롭게 컴파일 되어야 하는지를 자동적으로 판단해서 필요한 커맨드(gcc)를 이용해 재컴파일 하는 방식이다. wget 웹 서버로부터 콘텐츠를 가져오는 리눅스 명령어 cmake CMake도 Make와 마찬가지로 의존성 검사를 해서 Incremental Build를 수행하지만, 가장 큰 차이점은 CMake는 소스파일 내부까지 들여다보고 분석해서 의존성 정보를 스스로 파악한다는 점입니다. 예를 들어, 소스파일에 헤더파일을 추가(#include)하면, 직후 빌드부터 의존성 관계 변화가 자동으로 추적되어 헤더 파일의 변화까지 추적하기 시작합니다. - 📝 TUWLAB net-tools ifconfig, netstat, arp, route등의 명령을 사용하기 위한 패키지 bind-utils nslookup을 사용하기 위한 패키지 psmisc pstree, killall 같은 명령어를 사용하기 위한 패키지 ⏲ 서버 시간 동기화time_sync.sh 스크립트 생성 12#!/bin/bashrdate -s time.bora.net &amp;&amp; date &amp;&amp; clock -r &amp;&amp; clock -w &gt; /dev/null 2&gt;&amp;1 스크립트 실행권한 조정후 📁/etc/cron.hourly 이동 📁/etc/bashrc 로그인시 실행되는 스크립트 파일 디렉터리 🥚 파일 압축 관리 tar-c : 새 저장 파일을 만든다. 묶을때 사용-x : 묶인 파일을 해제할때-v : 처리 중인 파일을 자세하게 보여준다.-f : 파일을 저장 주로 묶을때는 -cvf 해제할때는 -xvf ✔️ 압축과 함께 묶인것을 풀어볼때는 -xvzf 🌐 네트워크 설정 📁/etc/sysconfig/network-scrips/ifcfg-인터페이스 🔧 DHCP설정이나 BOOTPROTO:”stiaic”(고정아이피)설정을 조정할 수 있다.📑 실습때 사용한 환경설정 12345BOOTPROTO = &quot;static&quot; //고정 아이피 설정IPADDRESS = &quot;~~&quot;NETMASK = 255.255.255.0GATEWAY = 192.168.1.1DNS1 = 168.126.63.1 //KT DNS 이후 # systemctl restart network.service 로 네트워크 다시 시작. 🌳 리눅스 파일 시스템VFS (Virtual File System) 리눅스 커널의 특징으로 디스크, 터미널, 네트워크 카드등의 모든 주변 장치들을 파일로 취급하는것 FHS (File Hierarchy System) /bin시스템 관리자 혹은 일반 사용자가 실행 할 수 있는 명령어들을 포함한 디렉터리 cat chmod date ls mkdir rm … /sbin시스템 관리자가 사용할 수 있는 명렁어들. 시스템에 관한 수정 복구 에 관한 명렁어를 포함한다. ifconfig reboot shutdown mount fsck /devudev라는 데몬이 장치 파일들을 관리하는곳 /etc시스템 혹은 각종 프로그램들의 환경 설정 파일들이 위치. /mnt마운트를 위한 임시 디렉터리가 위치. /varlog 파일같은 수시로 업데이트 되는 파일들이 위치. /usr/bin응용 프로그램들의 실행파일들이 위치","link":"/2019/05/04/19.05.05 리눅스 정리/"},{"title":"리눅스 정리 2","text":"🌐네트워크 , 💻 Shell 스크립트 리눅스 (필기한것 위주로) 🌐 네트워크 💻 Shell 스크립트 “/dev/null 2&gt;&amp;1” 리눅스 (필기한것 위주로) 리눅스는 윈도우와는 달리 루트 디렉터리가 하나라는 특징을 갖고있다. 각 파티션이 FHS(파일시스템 계층 구조)에 따라 마운트된다. 오류상황에 대해 각각이 독립적이라는 특징을 의미한다. 🌐 네트워크- NAT : 공유기를 통해 request/response 요청이 발생할때 네트워크 주소변환을 의미한다.- 📁 /etc/sysconfig/iptables에서 방화벽 포트설정에 관한 정보를 담고있다.- 고정 아이피 할당 : 📁/etc/sysconfig/network-scrips/ifcfg-인터페이스 에서 DHCP설정이나 BOOTPROTO:&quot;stiaic&quot;(고정아이피)설정을 조정할 수 있다. /etc/sysctl.conf : systemctl은 kernel parameter 값들을 조정하기위한 유틸리티로써/etc/sysctl.conf 에서는 커널차원에서의 보안 및 최적화 관련 설정을 수행한다. 💻 Shell 스크립트 ; - 앞의 명령어가 실패해도 다음 명령어가 실행 &amp;&amp; - 앞의 명령어가 성공했을 때 다음 명령어가 실행 &amp; - 앞의 명령어를 백그라운드로 돌리고 동시에 뒤의 명령어를 실행 ### \"/dev/null 2>&1\" 1$ rm test &gt; /dev/null 표준 출력을 /dev/null(항상 비어있는 특수파일) 으로 &gt; (redirection) 하라는 의미로 No description 0 표준 입력 1 표준 출력 2 표준 에러 해당하는 번호의 내용을 읽은 후 &gt;을 사용해 redirection 하라는것으로 이해하자. 1$ foo.sh 1&gt;output.log 2&gt;error.log","link":"/2019/05/05/19.05.06 리눅스 필기/"},{"title":"조인 (JOIN)","text":"🙏 조인 (JOIN) 조인 (JOIN) 조인 (JOIN) 보통 PK와 FK값의 연관에 의해 JOIN이 성립 INNER JOIN : 조인 조건을 만족하는 행에 대해서만 결과값이 나오는 조인 EQUI JOIN : =(equal) 연산자를 사용하는 조인 JOIN ON : 공통된 이름의 컬럼이 없는 경우조인 조건은 ON에 두어 사용한다. 123FROM employees aJOIN titles b ON ( a.emp_no = b.emp_no )WHERE a.gender = 'f' AND b.title = 'Engineer'; NATURAL JOIN : 별다른 조건없이 묵시적으로 공통컬럼을 이용해 조인되는 유형 ❗️ NAUTRAL JOIN은 여러개의 컬럼이 공통컬럼에 속하게 되는 위험성이 존재한다. 123SELECT *FROM employeesNATURAL JOIN titles; JOIN ~ USING : 사용되는 테이블간에 동일한 이름과 형식의 컬럼이 둘 이상인 경우 USING(컬럼)의 형식으로 조인하는 유형 12345SELECT 컬럼, 컬럼, …FROM 테이블1JOIN 테이블2 USING(조인 컬럼)[JOIN 테이블3 USING(조인 컬럼)] …WHERE 검색 조건; JOIN ~ ON : 공통된 이름의 칼럼이 없는 경우 가장 보편적으로 사용 할 수 있는 유형 12FROM employees aJOIN titles b ON ( a.emp_no = b.emp_no ) OUTER JOIN : JOIN 조건에서 동일한 값이 없는 행도 반환할 때 사용한다 즉 A, B 테이블을 JOIN 할 경우, 조건에 맞지 않는 데이터도 표시하고 싶을 때 OUTER JOIN을 사용한다","link":"/2019/05/07/19.05.07 JOIN/"},{"title":"부질의 (SubQuery)","text":"💭 Subquery (부질의) 💭 Subquery (부질의) ☝️ 단일행 서브쿼리 ❗ 서브 쿼리 사용시 유의점 📜 실습문제 1. 현재 전체사원의 평균 연봉보다 적은 급여를 받는 사원의 이름, 급여를 나타내세요. 📜 실습문제 2. 현재 가장적은 평균 급여를 받고 있는 직책에서 평균 급여를 구하세요. 🤘 다중행 서브쿼리 📜 현재 50000 보다 많은 급여를 받는 사원의 이름과 급여를 구하세요 💭 Subquery (부질의) 주로 where 조건에 작용하는 하나의 쿼리로써, 내부질의를 통해 외부의 본 목적인 쿼리를 해석할 수 있게 하는것. ✔️ 원칙적으로는 서브쿼리 내에서 order by 절을 포함할 수 없다. ☝️ 단일행 서브쿼리 메인 쿼리로 전달 되는 행이 하나일 경우를 말한다. ✔️ 서브쿼리에서 메인쿼리로의 전달은 주로 하나의 오퍼레이터로 이루어진다. ❗ 서브 쿼리 사용시 유의점 FROM 절에 오는 테이블 위치에 서브쿼리를 alias시킨 테이블을 선언하여 사용 하는 방법도 있음을 유의하자. 📜 실습문제 1. 현재 전체사원의 평균 연봉보다 적은 급여를 받는 사원의 이름, 급여를 나타내세요.123456789SELECT Concat(a.first_name, ' ', a.last_name) AS NAME, b.salaryFROM employees a, salaries bWHERE a.emp_no = b.emp_no AND b.to_date = '9999-01-01' AND b.salary &lt; (SELECT Avg(salary) FROM salaries WHERE to_date = '9999-01-01'); ### 📜 실습문제 2. 현재 가장적은 평균 급여를 받고 있는 직책에서 평균 급여를 구하세요. > 서브쿼리의 테이블을 **Alias 시킨후 FROM절에서 사용** 한 예제 12345678SELECT Min(avg_salary)FROM (SELECT Round(Avg(a.salary)) AS avg_salary FROM salaries a, titles b WHERE a.emp_no = b.emp_no AND a.to_date = '9999-01-01' AND b.to_date = '9999-01-01' GROUP BY b.title) a; 🤘 다중행 서브쿼리 메인쿼리로의 전달 되는 서브쿼리의 행이 여러개인 경우 다중행 연산자 IN ANY ALL 을 사용한다. 📜 현재 50000 보다 많은 급여를 받는 사원의 이름과 급여를 구하세요123456789101112SELECT a.first_name, b.salaryFROM employees a, salaries bWHERE a.emp_no = b.emp_no AND b.to_date = '9999-01-01' AND ( a.emp_no, b.salary ) IN (SELECT emp_no, salary -- 'in(sub_query)' &lt;-&gt; ='any(sub_query)' FROM salaries WHERE to_date = '9999-01-01' AND salary &gt;= 50000); ✔️ 서브쿼리에서 SELECT한 속성으로 이루어진 테이블을 참조 하여 WHERE절에서 해당 컬럼을 선택해 판별 할 수 있다.","link":"/2019/05/08/19.05.08 서브쿼리 (SubQuery) /"},{"title":"AWS 프리티어 과금","text":"💸 프리티어 기간을 지나서 요금이 청구됐을때 AWS 프리티어는 1년간 해당하는 서비스를 무료로 이용할 수 있게하는 모델이다. 작년부터 만들고 진행한 프로젝트를 EC2와 RDS 프리티어를 이용해서 배포하고 있었는데 지난달 취업 후 시간이 별로없어 서버관리에 신경을 못썼다. 프리티어의 한도가 초과되어 과금이 발생하면 등록한 이메일로 Notification을 보내는 서비스를 사용중이어서 메일을 받으면 서비스를 종료하려고 생각하던 와중에 이번달 요금이 얼마나 청구됐나 체크해봤는데 매달 Route 53 이용에 청구되던 액수보다 너무 많았다. 1년이 지나간 시점에서 프리티어가 종료되었고 Notification의 서비스도 종료되었기 때문에 이런 문제가 발생한것 같았다. 내 경우는 메일을 받으면 서비스를 종료하려고 했었는데 이미 과금이 발생한 경우였는데 프리티어 과금에 관한 내용을 검색해보니 1~2회?에 한에서 과금에 관한 조정이 가능하다는 말이 있어서 번역기의 도움을받아 확인차 문의을 넣어봤다. The ec2 free tier and rds we used last month cost a lot.Did my free tier closed?I was using a notification service to check the free-tier quota, but I was embarrassed by the unexpected charge.I did not get the charge because I did not have money in the account I registered, but can you get rid of the charge? 문의를 넣고 얼마 지나지 않아 답변을 받을 수 있었다. 답변 내용을 요약해보면 결제 조정을 준비하기위해 내 계정의 청구 금액을 모니터링한 후 더이상 과금되지 않는다면결제 조정에 관한 요청을 준비할것 이라는 답변이었다. 이후 하루동안 모니터링이 이루어졌고 4월의 청구액에 더해 5월 9일까지의 청구금액도 크레딧 사용을 통해 조정될 수 있었다.","link":"/2019/05/09/19.05.10 AWS 프리티어 사용중 과금이 청구됐다/"},{"title":"Java OOP","text":"📖 Java OOP 📖 Java OOP 📖 Java OOP* [현실을 그대로 옮긴다](#현실을-그대로-옮긴다) * [♻️ 재사용한다는 의미](#️-재사용한다는-의미) * [일반화와 추상 클래스](#일반화와-추상-클래스) * [Referencing 해서 부모객체(추상 클래스)를 사용하기](#referencing-해서-부모객체추상-클래스를-사용하기) ⭐ SOLID by 📔 Limky SRP (Single Responsibility Principle) 단일 책임 원칙 OCP (Open Closed Principle) 개방 폐쇄 원칙 LSP (Liskov Substitution Principle) 리스코프 치환 원칙 ISP (Interface Segregation Principle) 인터페이스 분리 원칙 DIP (Dependency Inversion Principle) 의존 역전 원칙 🔍 객체 Reflection #️⃣ HASHING 📌 Hashcode() 와 Equals() = equals ❓ 왜 hashcode를 equals와 같이 오버라이드 해야되는지 현실을 그대로 옮긴다현실의 객체들이 가지고 있는 속성과 기능들 중에서 중요한 것들만 남기고 불필요한 것은 없애게 된다. 이러한 과정을 “추상화 한다.” 라고 말한다. ♻️ 재사용한다는 의미클래스를 다시 사용하는것이 아니라 추상화를 통해 확장시키는것의 의미이다 일반화와 추상 클래스 인스턴스가 될 수 없는 클래스를 “추상 클래스”라고 한다. 추상 클래스 : 상속을 통해 확장하는 개념의 클래스로 어떤것에 관한 공통적인 기능, 속성을 담고있어 “일반화”된 것이다. Referencing 해서 부모객체(추상 클래스)를 사용하기1Car c = new Bus(); 객체생성시의 유연하고, 확장성 있는 객체를 만들수 있다는 장점 1234Car c = new Bus();c.달리다();c.안내방송하다(); // 불가c.주차(); // 오버라이드 ⭐ SOLID by 📔 Limky 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion - Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것이다. ✔️ 다시말해 응집도가 높은 각 모듈을 재사용함으로써, 수정을 최소화하여 유지보수를 용이하기 위함이다. SRP (Single Responsibility Principle) 단일 책임 원칙 하나의 클래스안에 많은 속성을 넣지말고, 필요한 클래스의 역할과 목적에 맞는 속성과 메서드들을 추려 하나의 클래스들로 각각 만들어야 한다. ### OCP (Open Closed Principle) 개방 폐쇄 원칙 > 개발 방향을 상위 클래스 혹은 인터페이스를 중간에 두어 직접적인 연동을 피하게 설계한다. ### LSP (Liskov Substitution Principle) 리스코프 치환 원칙 > 상속의 개념을 위아래 계층으로 나누는것이 아닌 분류하는것으로 생각하는 관점으로 상속을 확장의 개념으로 설계하는것 ❌ Father harry = new Son(); - 해리라는 이름의 아들이 아버지의 행동을한다.⭕ Animal mickey = new Rat(); - 미키라는 이름의 쥐가 동물의 행동을 한다. ✔️ 클래스의타입 이름 = new 하위클래스();로 기억하자. ISP (Interface Segregation Principle) 인터페이스 분리 원칙 SRP와 같은 원인에 대한 다른 해결책을 제시한다.이미 만들어진 여러개의 속성과 메서드를 인터페이스 를 통해 필터링하여 상황에 맞게 사용한다는 방식 ### DIP (Dependency Inversion Principle) 의존 역전 원칙 > 상위 클래스가 하위클래스를 의존하는 상황을 인터페이스나 상위클래스를 하나 더 두어 의존하고 있는 방향을 역전 시키는것 ✔️ 의미적으로 OCP 개방 폐쇄 원칙 과 유사하다. 🔍 객체 Reflection 클래스의 내부정보를 조회하거나 조작하는 기법 #️⃣ HASHING text, address, 객체내의 int, string, boolean값들을 int값으로 만든것. 검색을 빨리하기위해서 사용한다 중복될수있다 데이터 자체가 같은지 비교하고 같다면 데이터의 내용이 같은지를 다시 비교하는식으로 검색 📌 Hashcode() 와 Equals()= equals1234567891011Point p1 = new Point(10, 20);Point p2 = new Point(10, 20);Point p3 = p2;// == : 두객체의 동일성System.out.println(p1 == p2);System.out.println(p2 == p3);//equals : 두 객체의 동질성 비교한다. (내용비교)System.out.println(p1.equals(p2)); System.out.println(p2.equals(p3)); ✔️ String을 equals() 메서드로 비교할때, String 문자열끼리 비교되는 반면✔️ Point객체는 Override가 안되어있기 때문에 == 로 비교되어 false를 반환한다. ❓ 왜 hashcode를 equals와 같이 오버라이드 해야되는지 hashmap, hashset같은 자료구조들의 비교 과정에서성능이 떨어지는 문제 때문에 hashcode를 구현해서 같이 쓴다. 1234567891011121314Set&lt;Point&gt; set = new HashSet&lt;Point&gt;();Point p1 = new Point(10, 20);set.add(p1);Point p2 = new Point(100, 200);set.add(p2);Point p3 = new Point(10, 20);set.add(p3);for(Point p : set) { System.out.println(p);} 1234Point [x=100, y=200]Point [x=10, y=20]hashcode()가 Override 되어있을경우 두개만 출력된다 12345Point [x=100, y=200]Point [x=10, y=20]Point [x=100, y=200]equals만 있다면 세개가 모두 출력 1234567String str1 = new String(\"ABC\"); String str2 = new String(\"ABC\"); System.out.println(str1 == str2); System.out.println(str1.equals(str2)); System.out.println(str1.hashCode() + \" : \" + str2.hashCode()); System.out.println(System.identityHashCode(str1) + \" : \"+System.identityHashCode(str2)); 1234falsetrue64578 : 64578 //이미 Override되어있기 때문366712642 : 1829164700 12345678String str3 = \"ABC\";String str4 = \"ABC\";System.out.println(str3 == str4);System.out.println(str3.equals(str4));System.out.println(str3.hashCode() + \" : \" + str4.hashCode());System.out.println(System.identityHashCode(str3) + \" : \"+System.identityHashCode(str4)); 123456truetrue64578 : 645782018699554 : 2018699554//모두 같은 객체이다. String str3 = “ABC”; 의 과정에서는 ABC라는 string의 hashcode값을 메모리에 저장한다. 이후 String str4 = “ABC”; 의 step에서는 같은객체가 있는지 확인한뒤 있다면 같은 객체를 참조하도록 한다. 위와같은 과정은 변수선언을 Literal로 하는 방법이 변수를 재사용하여 사용하기 때문에 유용하다는 점을 시사한다.","link":"/2019/05/10/19.05.10 Java OOP/"},{"title":"JDBC ( Java Database Connectivity )","text":"📖 JDBC ( Java Database Connectivity) 🔌 자바와 데이터베이스의 연동 🔌 자바와 데이터베이스의 연동 드라이버 로딩 (JDBC Load) Class.forName(“드라이버 Path”) Class 클래스가 클래스의 정보(필드, 메서드 클래스의 종류)를 담는 메타 클래스이고JVM은 해당 클래스의 정보를 로드한다. DB 연결 Connection DriverManager.getConnection(url, ID, PWD) Connection 객체를 생성한후 DriverManager에서 시스템 프로퍼티 “jdbc.drivers”에 참조된 드라이버 클래스를 로드한다. 이후 Connection 객체에 할당 쿼리 생성 및 질의 1234567PreparedStatement psmt = null;psmt = conn.prepareStatement(\"SQL문\");Statement stmt = null;stmt = conn.createStatement(\"SQL문\"); ✔️ PreparedStatement는 쿼리에 ?로 매개변수를 받아 실행 가능 쿼리 실행 psmt.executeUpdate() INSERT UPDATE DELETE 같은 값을 받아오지 않는 쿼리문은 psmt.executeUpdate()로 실행 psmt.executeQuery() SELECT 처럼 결과 테이블이 필요한 쿼리문은 쿼리 실행 이전에 ResultSet객체를 생성한후 psmt.executeQuery()를 할당한다. ResultSet 처리 123456while(rs.next()) { int i=1; int id = rs.getInt(i++); String name = rs.getString(i++); String addr = rs.getString(i++); } Close() 1234567891011121314151617181920if (rs!=null) { try { rs.close(); } catch (SQLException e) { }}if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { }}if(conn!=null) { try { conn.close(); } catch (SQLException e) { }} ✔️ Open한 객체들의 역순으로 close 시킨다.","link":"/2019/05/12/19.05.11 JDBC/"},{"title":" Servlet & JSP 上","text":"📄 Servlet &amp; JSP 📖 Servlet &amp; JSP 上 Model1 🌐 Model2 (JSP + Servlet) 🔍 MVC 📁 디렉터리 구조 📁 web.xml 구조 ( war 빌드시 필요 ) 📄 JSP ↪️ Dispatcher / Redirect Dispatcher : forward(request, response) Redirect : sendRedirect(url) 📖 Servlet &amp; JSP 上 톰캣에서 어떤 URL을 요청했을때 어떤 Servlet파일을 실행시킬것인지 web.xml을 통해 변환되며, Servlet은 그 요청에 맞게 응답하게 되는 구조이다. Model1 JSP에서 요청 페이지를 판단하는 흐름 🌐 Model2 (JSP + Servlet) 웹 브라우저의 요청을 하나의 Servlet이 받게된다. Servlet은 웹브라우저의 요청을 jsp페이지로 포워딩하여 처리한다. 🔍 MVC MVC패턴의 핵심은 비즈니스 로직을 처리하는 모델과 화면을 보여주는 뷰가 분리되어있고 어플리케이션의 흐름제어나 request를 컨트롤러에 집중하게 되는것이다. 📁 디렉터리 구조 📁 web.xml 구조 ( war 빌드시 필요 ) 📄 JSP Request/Response 객체를 내장하고있다.&lt;% codeblock %&gt;으로 Java 코드를 사용해서 HTML 구조를 조작할 수 있다. request 웹브라우저의 요청과 관련해 사용하는 객체 getParamter() response 웹브라우저의 응답과 관련해 사용하는 객체 sendRedirect() ↪️ Dispatcher / RedirectDispatcher : forward(request, response) 클라이언트가 요청하면서 전송한 데이터를 그대로 유지한다.(같은 request객체를 보존한 상태로 이동) Redirect : sendRedirect(url) request객체가 없어지면서 새로운 페이지로 이동한다. ✔️ 매개변수로 어떤 객체가 올 수 있는지 생각하자","link":"/2019/05/13/19.05.13 Servlet & JSP 上/"},{"title":"애드센스 핀(PIN)번호가 왔다","text":"📬 애드센스 지급 승인 받기 지난번 프로젝트에 애드센스 광고를 달았는데 생각보다 10달러를 넘겼다. 애드센스는 지급 수입이 10달러를 초과했을때 PIN번호를 우편으로 보내고 우편을 받은 이용자가 애드센스에 핀번호를 인증하는 절차를 거치는데 내 경우에는 지난달 4월15일에 PIN번호 우편 지급을 신청하고 이번주 금요일인 5월 10일에 도착해서 약4주정도 소요됐다. 배송지 추적이나 발송은 됬는지 확인할 방법이 없어서 불편했다. 너무 늦게오는거 아닌가 싶어서 구글링을 해봤었는데 PIN번호 재발급을 눌러서 다시받는 방법도 있다. 다시 받아도 PIN번호는 바뀌지 않는 상태로 재발송되기 때문에 안온다 싶으면 눌러봐도 좋을듯 인증 완료 👍","link":"/2019/05/11/19.05.11 애드센스 핀(PIN)번호가 왔다/"},{"title":"캐시와 스토리지","text":"☕ 캐시와 스토리지 * [HDD SSD NVMe](#hdd-ssd-nvme) * [사용자 캐시, DB 캐시, 어플리케이션 캐시](#사용자-캐시-db-캐시-어플리케이션-캐시) * [어플리케이션에 있던 캐시의 증가](#어플리케이션에-있던-캐시의-증가) * [Reverse Proxy](#reverse-proxy) * [Vanish](#vanish) * [restful api 캐시](#restful-api-캐시) ☁️ Storage Storage 분류 HDD SSD NVMe 사용자 캐시, DB 캐시, 어플리케이션 캐시 HDD에 캐시를 저장하면 느리기 때문에 주로 메모리에 저장한다. DB의 경우는 HDD에 저장할수 밖에 없는 케이스. Redis, Memcahced : 어플리케이션에 저장되는 캐시 어플리케이션에 있던 캐시의 증가 동기화 hashkey?를 이용 기존에있던 캐시는 expire(만료), 주기적으로 쪼개기? 모듈별, 기능단위별 캐시를 만드는 경우도 있다 Reverse ProxyVanish 어떤 응답값에 대해서 restful api 캐시모듈화를 잘해놔야 이용이 쉽다. ☁️ Storage 기존의 디스크와는 다른 네트워크 클러스터로 구성된 여러개의 디스크를 이용해 구성된 것? - Replica : 똑같은 데이터를 여러개 복제 - Shard : 분산, 하나의 데이터를 여러개로 나누어서 저장한느것Replication + shard =&gt; 하나의 DISK가 죽어도 다른곳에서도 데이터를 구할 수 있다. Storage 분류 파일 스토리지 파일디렉터리 구조로 된 스토리지 기존 파일시스템과 호환성을 갖는다. 동시 쓰기 읽기가 가능하다 오브젝트 스토리지 S3 (이미지에 적합) 물리적인 제약이 없는 논리적 스토리지 블록 스토리지 동시 읽기 쓰기가 불가 (DB)","link":"/2019/05/13/19.05.13 캐시와 스토리지/"},{"title":" Servlet & JSP 中","text":"📄 Servlet &amp; JSP 中 📖 Servlet &amp; JSP 中 📮 Servlet &amp; JSP 예제 📝 Example 🔑 로그인 🔧 회원 정보수정 🌐 Session / Request* [📨 Request](#request) * [📡 Session](#session) ↪️ Dispatcher / Redirect 🔗 Dispatcher : forward(request, response) 〽️ Redirect : sendRedirect(url) 📖 Servlet &amp; JSP 中📮 Servlet &amp; JSP 예제 📝 Example🔑 로그인 사용자가 로그인 메뉴 클릭 브라우저에서 /context/user?a=loginform request. user에 Mapping 되어있는 UserServlet의 doGet() 호출 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String actionName = request.getParameter(\"a\"); Action action = new UserActionFactory().getAction(actionName); action.execute(request, response); } a의 매개변수로 쓰여진 loginform을 actionName이라는 String객체로 받아 UserActionFactory에서 해당하는 Action 실행 123else if(\"login\".equals(actionName)) { action = new LoginAction();} Email과 Password를 &lt;form action=&quot;path&quot;&gt;으로 전달 받아 UserDao의 get메서드를 통해 일치하는 authUser 객체 생성 1234567891011121314151617181920@Overridepublic void execute(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { String email = request.getParameter(\"email\"); String password = request.getParameter(\"password\"); UserVo authUser = new UserDao().get(email, password); if(authUser == null) { request.setAttribute(\"result\", \"fail\"); WebUtil.forward(request, response, \"/WEB-INF/views/user/loginform.jsp\"); return; }// 로그인처리 HttpSession session = request.getSession(true); session.setAttribute(\"authUser\", authUser); WebUtil.redirect(request, response, request.getContextPath()+\"/main\");} 앞에서 생성한 authUser를 session에 세팅하고 메인 페이지로 Redirect. 🔧 회원 정보수정 로그인 후 세션이 살아있는 상태에서 사용자가 정보수정 링크 클릭 브라우저에서 /user?a=updateform request. user에 Mapping 되어있는 UserServlet의 doGet() 호출 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String actionName = request.getParameter(\"a\"); Action action = new UserActionFactory().getAction(actionName); action.execute(request, response); } a의 매개변수로 쓰여진 loginform을 actionName이라는 String객체로 받아 UserActionFactory에서 해당하는 Action 실행 123}else if(\"updateform\".equals(actionName)) { action = new UpdateformAction();} 로그인 되어 저장상태의 세션을 가져오고 로그인되어있는 아이디의 키값 추출, 키값으로 찾은 User를 authUser세션으로 새로 저장 123456789101112131415161718192021222324252627@Override public void execute(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { // 접근제어 HttpSession session = request.getSession(); if(session == null || session.getAttribute(\"authUser\") == null) { WebUtil.redirect(request, response, request.getContextPath()+\"/main\"); return; } UserVo authUser = (UserVo)session.getAttribute(\"authUser\"); if(authUser == null) { WebUtil.redirect(request, response, request.getContextPath()); return; } Long userNo = authUser.getNo(); UserVo userVo = new UserDao().get(userNo); request.setAttribute(\"userVo\", userVo); session.setAttribute(\"authUser\", authUser); WebUtil.forward(request, response, \"/WEB-INF/views/user/updateform.jsp\"); } updateform.jsp 에서 &lt;form action=&quot;/?a=update&quot;&gt;으로 전달 받아 UserServlet에서 다시 UpdateAction까지 폼값 전달 UserDao.update(vo)를 통해 update 쿼리를 실행 후 String sql = “update user set name=?, email=?, password=?, gender=? where no=?”; 변경된 닉네임이 표시되도록 변경된 User정보를 세션에 다시 실어 메인 페이지로 Redirect. ❗ URL 요청 -&gt; Servlet -&gt; ActionFactory -&gt; 판별된 Action() 실행 -&gt; Redirect OR forward 🌐 Session / Request📨 Request Method description .getParamter(name) name에 저장되어있는 문자열 반환 .getContextPath() 프로젝트 Path 📡 Session 서버쪽에 상태 유지를 위한 정보를 저장하는것 Method description .getAttribute(String name) name에 저장되어있는 Object 타입으로 반환 없을 경우 NULL .setAttribute(String key , Object value) name인 속성에 value 오브젝트 할당 .invalidate() 현재 생성된 세션을 종료 ↪️ Dispatcher / Redirect🔗 Dispatcher : forward(request, response) 클라이언트가 요청하면서 전송한 데이터를 그대로 유지한다.(같은 request객체를 보존한 상태로 이동) 〽️ Redirect : sendRedirect(url) request객체가 없어지면서 새로운 페이지로 이동한다. ✔️ 매개변수로 어떤 객체가 올 수 있는지 생각하자","link":"/2019/05/14/19.05.14 Servlet & JSP 中/"},{"title":"Spring Basic","text":"🍃 Spring Basic 🍃 Spring 🤾 주요 전략 📦 Container 🔮 POJO 📢 🔍DispatcherServlet 💨 동작 방식 🍃 Spring POJO 특정 클래스를 상속하거나 인터페이스를 구현하지 않는 평범한 자바 클래스(느슨한 결합)를 이용하며 단순하지만 EJB에서 제공하는 고급 기술을 제공한다. ✔️ EJB의 무거웠던 단점을 보완해 나온 Spring은 경량급 프레임워크로 RELEASE되었다. 🤾 주요 전략1. POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive) 개발 2. DI와 인터페이스 지향을 통한 느슨한 결합도(loose coupling) 3. Aspect와 공통 규약을 통한 선언적(declarative) 프로그래밍 4. Aspect와 템플릿(template)을 통한 반복적이고 상투적인(boilerplate) 코드 제거📦 Container 객체관리를 주로 수행하는 그릇으로 빈의 생성과 관계, 사용, 생명 주기등을 관장하는곳.프로젝트내의 수많은 객체들을 생성하기위한 new, getter/setter 들은 객체들끼리 서로 참조되고있다.이러한 상태를 의존성이 높은 결합도를 띈다라고 표현하는데, 결국 객체지향 프로그래밍에 상반되는 형태를 띄는것이다.이러한 높은 의존성을 낮추기위해 사용하는것이 Spring Container 이다. 🔮 POJO Plain Old Java Object, 객체지향 프로그래밍의 본 목적에 맞게 사용하기위한 특정 환경에종속되지 않는 간결한 클래스를 말한다. Inversion Of Container 객체의 생성과 사용하는 행위를 담당하는 주체가 Container로 넘어가는것을 말한다. Dependency Injection Container 외부에서 생성된 객체를 setter 혹은 생성자를 이용해 특정상황에서 객체끼리 의존하는 상황일때 IoC컨테이너에서 생성된 객체를 넘겨주어 사용 할 수 있게하는것. PSA (Portable Service Abstraction) 환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하려는 추상화 구조 AOP (Aspect Oriented Programming ) 기존에 OOP에서 바라보던 관점을 다르게하여 부가기능적인 측면으로 보았을때 공통된 요소를 추출해 내 재사용하는것. (로깅, 트랜잭션, 보안) 📢 🔍DispatcherServlet Servlet Container (tomcat)에서 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에둬서중앙집중식으로 처리해주는 Front Controller. 💨 동작 방식","link":"/2019/05/15/19.05.15 Spring Basic DAY-1/"},{"title":"Servlet & JSP 下","text":"📄 Servlet &amp; JSP 下 📮 Servlet &amp; JSP URLMapping DefaultServlet 💲 JSTL 📚 JSTL Library Core (prefix:c) Formatting (prefix:fmt) Function (prefix:fn) 💬 문법 🔭 Scope 우선순위 다른 JSP 문서 참조하기 📮 Servlet &amp; JSPURLMapping 첫번째 web.xml의 &lt;servlet&gt;블록과 &lt;servlet-mapping&gt;블록을 통해 설정하는 방법과두번째 Servlet 클래스 객체에 @WebServlet(&quot;/example&quot;) 어노테이션을 사용해 매핑하는 방법이 있다. ✔️ 동시에 두 방법을 사용할 경우 에러 DefaultServlet web.xml에는 지정한 &lt;servlet&gt;블록에서 mapping되지 않은 static한 리소스들이나 url로의 접근은 내부적으로 정의되어있는 DefaultServlet에 의해 / 로 전달된다. 💲 JSTL📚 JSTL LibraryCore (prefix:c) 변수선언, 실행흐름의 제어, 페이지 이동 Formatting (prefix:fmt) 숫자, 날짜, 시간등의 포매팅 기능 Function (prefix:fn) 문자열 함수 제공 💬 문법 &lt;c:choose&gt; : if ~ else if ~ else 서브태그로 &lt;c:when&gt;과 &lt;c:otherwise&gt; test 조건에서 지정한 질의를 판별 &lt;c:forEach&gt; items 로 iterate할 객체를 정하고 iterate하는 각각의 index 객체를 var 로 지정 varStatus 는 과정 속의 index값 step 증감하는 값 &lt;c:set&gt; : 변수에 값을 설정 &lt;c:import&gt; : 다른 페이지를 동적으로 포함시킬때 사용 123&lt;c:import url=\"url\"&gt; &lt;c:param name=\"변수이름\" value=\"값\"&gt;&lt;/c:param&gt; &lt;/c:import&gt; 🔭 Scope 우선순위1234graph LR A[PageScope] --&gt; B[RequestScope] B[RequestScope] --&gt; C[SessionScope] C[SessionScope] --&gt; D[ApplicationScope] 다른 JSP 문서 참조하기1&lt;jsp:include page=\"/WEB-INF/views/include/navigation.jsp\" /&gt; 123&lt;c:import url=\"url\"&gt; &lt;c:param name=\"변수이름\" value=\"값\"&gt;&lt;/c:param&gt; &lt;/c:import&gt;","link":"/2019/05/15/19.05.15 Servlet & JSP 下/"},{"title":"Spring Basic","text":"🍃 Spring Basic 🍃 Spring POJO 특정 클래스를 상속하거나 인터페이스를 구현하지 않는 평범한 자바 클래스(느슨한 결합)를 이용하며 단순하지만 EJB에서 제공하는 고급 기술을 제공한다. ✔️ EJB의 무거웠던 단점을 보완해 나온 Spring은 경량급 프레임워크로 RELEASE되었다. 🤾 주요 전략1. POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive) 개발 2. DI와 인터페이스 지향을 통한 느슨한 결합도(loose coupling) 3. Aspect와 공통 규약을 통한 선언적(declarative) 프로그래밍 4. Aspect와 템플릿(template)을 통한 반복적이고 상투적인(boilerplate) 코드 제거📦 Container 객체관리를 주로 수행하는 그릇으로 빈의 생성과 관계, 사용, 생명 주기등을 관장하는곳.프로젝트내의 수많은 객체들을 생성하기위한 new, getter/setter 들은 객체들끼리 서로 참조되고있다.이러한 상태를 의존성이 높은 결합도를 띈다라고 표현하는데, 결국 객체지향 프로그래밍에 상반되는 형태를 띄는것이다.이러한 높은 의존성을 낮추기위해 사용하는것이 Spring Container 이다. 🔮 POJO Plain Old Java Object, 객체지향 프로그래밍의 본 목적에 맞게 사용하기위한 특정 환경에종속되지 않는 간결한 클래스를 말한다. Inversion Of Container 객체의 생성과 사용하는 행위를 담당하는 주체가 Container로 넘어가는것을 말한다. Dependency Injection Container 외부에서 생성된 객체를 setter 혹은 생성자를 이용해 특정상황에서 객체끼리 의존하는 상황일때 IoC컨테이너에서 생성된 객체를 넘겨주어 사용 할 수 있게하는것. PSA (Portable Service Abstraction) 환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하려는 추상화 구조 AOP (Aspect Oriented Programming ) 기존에 OOP에서 바라보던 관점을 다르게하여 부가기능적인 측면으로 보았을때 공통된 요소를 추출해 내 재사용하는것. (로깅, 트랜잭션, 보안) 📢 🔍DispatcherServlet Servlet Container (tomcat)에서 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에둬서중앙집중식으로 처리해주는 Front Controller. 💨 동작 방식","link":"/2019/05/15/19.05.15 Spring Basic/"},{"title":"Spring Annotation 과 Service","text":"🍃 Spring Basic 🍃 Spring Basic 🍃 Spring Basic 📢 DispatcherServlet 💨 DispatcherServlet 동작 방식 🔖 주요 Annotation @ResponseBody @RequestMapping @RequestParam @Autowired @PathVariable @ModelAndView 🎧Listener 🏛️ Layered Architecture 📌 Service 📢 DispatcherServlet 브라우저에서 보내는 요청을 가장 먼저 받는 Front Controller로써, request받은 요청을 HandlerMapping에게 질의한다. 💨 DispatcherServlet 동작 방식 HandlerMapping Map 구조 처럼 key(url) : value(method name or Parameter)로 구성되어 있는 형태이다. DispatcherServlet이 HandlerMapping에게 질의한 결과 찾아낸 URL이 Controller에게 전달되어 전달된 Parameter에 해당하는 메서드의 실행과 함께 Service계층에 정의되어있는 비즈니스 로직이 실행된다. 이후 실행한 메서드의 컨트롤러에서 비즈니스 로직의 결과로 리턴된 Model객체와 뷰 이름과 함께 반환되고 ViewResolver가 응답할 View를 찾아내 View객체에 요청을 전달하며 최종결과가 출력된다. 🔖 주요 Annotation@ResponseBody Annotation이 위치한 메서드에 View를 출력하는것이 아닌 return되는 자료형이 MessageConverter에 의해 변환되어 HTTP Response Body에 쓰여져 전송된다. Controller에서 View가 아닌 객체를 리턴해야 할 상황에서 (Ajax같은) 메서드의 리턴 자료형을 지정 할때 쓰인다. @RequestMapping 기본적으로 @RequestMapping(value=”parameter”, method.RequestMethod.(method_name))의 형태를 띄는 Annotation이다.method를 지정할 경우 value프로퍼티 형식은 필수적 이다.복수의 urlMapping을 위해서는 value={“parameter1”, “parameter2”}로 나타낸다. @RequestParam HttpServleRequest객체의 getParamter()와 비슷한 역할을 한다 특정 @RequestMapping로 실행된 메서드의 파라미터 유형을 /url?key=value처럼 지정할 수 있는 역할을 한다. @Autowired web.xml -&gt; &lt;context-param&gt; -&gt; &lt;context-annotation-config/&gt; 를 통해 Autowired Annotation을 사용한 클래스의 의존성을 낮춰 사용할 수 있게하는 역할을 한다 @PathVariable@RequestParam의 value값을 {param}으로 설정했을때의 값을 @PathVariable로 받아 메서드 매개변수로 선언한다 @ModelAndView 뷰에서 Controller로의 객체 전달이 이루어져야 할때 메서드의 매개변수로 사용한다. 🎧Listener ContextLoaderListener를 상속받아 contextIntialized 함수에 루트 컨테이너를 web.xml에 입력한 경로의 설정을 이용해 빌드하도록하는 역할 (예제에서는 /WEB-INF/applicationContext.xml를 토대로 스프링 컨테이너를 빌드하고 모든 서블릿이 공유하도록 했다.) 🏛️ Layered Architecture 📌 Service 스프링에서의 비즈니스 영역을 일반적으로 서비스라고 한다.비즈니스 계층은 컨트롤러와 DAO사이의 중복코드와 객체지향의 목적에 맞는 의존성을 유지하기 위해 사용하는 계층이다. - DAO의 메서드 단위가 트랜잭션 단위가 된다. - DAO의 CRUD기능 이외에 페이징 구현시 Service계층을 이용하는것이 대표적이다. - applicationContext.xml에서 특정 패키지가 @Service를 사용하도록 설정할 수 있다. - ERD를 이용한 방식과 유저 스토리를 작성하는 것으로 비즈니스 로직을 설계하고 `Service계층을` 구현한다.","link":"/2019/05/16/19.05.16 Spring Basic DAY-2/"},{"title":"웹서비스에서 인프라의 역할","text":"📈 인프라 설계의 지표 📖 인프라의 기본 DAY-1 📖 인프라의 기본 DAY-1 🏭 웹서비스에서 인프라의 역할 🏟️인프라 기술의 계층구조 ☁️ 클라우드 서비스 (IaaS/Paas) 📝 인프라 설계시 고려 요건 기능적 요건 비기능적 요건 인프라의 신뢰성 확보 : RAS / RASIS 📈 RAS의 인프라 신뢰성 확인 지표 가동률 장애 발생 간격 MTBF (Mean Time Between Failures) 평균 복구 시간 MTTR (Mean Time To Repair) 요소 각각의 가동률을 높이기 요소를 조합해 서비스의 가동률 높이기 Active-Standby #🏭 웹서비스에서 인프라의 역할 코로케이션 : 직접 서버를 관리를 하지 않고 인터넷 서비스를 제공하는 IDC 업체가 보유한 네트워크 망으로 서버를 연결하여 관리하는 서비스. 🏟️인프라 기술의 계층구조 layer OSI example 7 애플리케이션 계층 HTTP, SMTP, SSH, FTP 4 전송 계층 TCP,UDP 3 네트워크 계층 IP,ICMP 2 데이터링크 계층 Ethernet 1 물리 게층 RJ-45 인프라라고 하는것은 처리단계가 아니라 계층에 관하여 다루는 것이다. ☁️ 클라우드 서비스 (IaaS/Paas) 클라우드 서비스는 이러한 계층 구조를 이용해 특정 계층까지의 패키징을 제공하는것이다.IaaS (Infrastructure as a Service) : 서버나 네트워크 인프라부분을 인터넷을 통해 이용하는 것PaaS (Platform as a Service) : 인프라 부분을 신경쓰지 않고 준비된 개발환경을 인터넷 경유로 이용하는것 IaaS : AWS GCP Sofylayer PaaS : Heroku Google App Engine Engine Yard ✔️ EC2와 RDS는 각각 IaaS와 PaaS에 속한다 📝 인프라 설계시 고려 요건기능적 요건 동시 접속 수와 관련된 세션수, 로드 밸런싱과 관련된 서버의 대수등의 인프라의 기능적인 요소들 비기능적 요건 가용성 : 가동률, 목표 복구시간, 재해 대책 성능/확장성 : 성능 목표, 확장성 운용/유지보수성 : 운용시간, 백업, 운용 감시, 정기 보수 이행성 : 이행 방식의 규정, 이행 스케줄, 설비/데이터 보안 : 가이드라인과 네트워크 레벨 제어, DoS 공격 대책, 정보 유출 대책, 사고 발생시의 대응 시스템 환경 / 생태 환경 : 적합 규격, 기기 설치 규격, 환경 관리 인프라의 신뢰성 확보 : RAS / RASIS Reliability : 신뢰성 Availability : 가용성 Serviceability : 유지 보수성 Integretiy : 무결성 Security : 안전성 📈 RAS의 인프라 신뢰성 확인 지표가동률 가동률은 보통 MTBF/(MTBF+MTTR)로 계산한다. 123456가동률은 실제 비 엔지니어가 상상 할 수 있는 지표로써 작용하기에 가동률을 중심으로 각종 요소를 결정한다.가동률을 높이기 위한 방법으로는 &apos;다중화&apos;를 사용하는데장애가 발생한 경우 해당 요소외에 다른 구성 요소들이 처리를 넘겨받아 시스템 전체의 가용성을 높이는것을 말한다.이렇게 함으로써 SPOF (Single Point Of Failures) 단일 장애 포인트를 줄이는 방향으로의 조정을 행하는것이다. 장애 발생 간격 MTBF (Mean Time Between Failures) 누적 사용 시간 / 고장 횟수 평균 복구 시간 MTTR (Mean Time To Repair) 누적 수리 시간 / 고장 횟수 ✔️ 대게 서비스 제공을 위해 필요한 장비의 최소대수를 N으로 하면 평상시의 최소대수는 N+1의 구성을 취한다.✔️ MTTR아 분명할 것으로 예상된다면 N+2✔️ N+1이 N이 된후 다시 N+1이 될 때 까지가 장애 대응 이라 말한다. 요소 각각의 가동률을 높이기 서버용 부품의 사용 : MTBF를 길게 할 수 있는 기대효과 부품을 이중화하기 : 서비스 중지 방지 요소의 가동률 확인 : 가동률을 유지할 수 있는 기대효과 요소를 조합해 서비스의 가동률 높이기 다중화의 구성을 조정해 가동률을 높이는 것을 말한다.다중화된 요소를 모두 이용할 수 있는 ‘Active-Active’와 ‘Active-Standby’가 있다. Active-Standby Hot Standby Warm Standby Cold Standby","link":"/2019/05/16/19.05.16 웹서비스에서 인프라의 역할/"},{"title":"","text":"MyBatis MyBatis DataSource 🌟 MyBatis에 실효성과 목적에 관해 Mapper 인터페이스를 통해 지원하며 별도의 XML파일에 쿼리를 지정하여DAO에서의 DB접근 수단을 SqlSession 인터페이스를 구현한 클래스 객체를 DI 받아서 사용한다. DataSource DAO에서 Connection 객체를 매번 새로 생성하는것의 비효율성, 성능저하 때문에 사용하는 Bean. Pooling : Connection Pool에서 요청에 따라 꺼내고 돌려받아 저장 ✔️ Spring에서는 DataSource를 하나의 독립된 빈 객체로 만들길 권장하고 있다 ✔️ 📝configuration.xml에 Mapper경로와 이름이 정의되어있고 지정한 Mapper.xml파일에 XML의 문법을 따르는동적 형태의 쿼리문을 전달받아 DAO내에서 수월하게 사용하는것이다. 🌟 MyBatis에 실효성과 목적에 관해MyBatis의 의의는 이것에 있다. 기존의 JDBC코드에서의 Connection객체의 반복적인 사용을 방지하는것과 Service Controller DAO 와 같은 3-Layer로 이루어진 스프링 구조를 객체지향의 목적성에 맞게 느슨한 의존성을 따르게하는것이다.","link":"/2019/09/18/19.05.17 Spring DAY-3 MyBatis/"},{"title":"","text":"💀 Exception 💀 Exception Checked Exception / UnChecked Exception Service와 Exception ❓ 그럼 어떻게 처리해야 할까 Checked Exception / UnChecked Exception Checked Exception UnChecked Exception 엄격한 예외처리 과정 강제하지 않는 처리과정 컴파일 단계 실행단계 roll-back ❌ roll-back ⭕ RuntimeException을 제외한 모든 예외 RuntimeException 의 하위 예외 Service와 Exception 대개 Service계층에서는 비즈니스 로직을 수행하는 본 목적에 맞게 Exception처리는 하지 않는다.이 말은 필수적인 것 과는 다른 의미로써 Exception처리의 필요성이 없다고 이해하고 넘어가자. ❓ 그럼 어떻게 처리해야 할까 Service와 Controller 계층에서 처리하는것이 아닌 DAO에서 Exception처리가 이루어진다.예제의 UserDAO에 SQLException은 처리는 Exception을 상속받아 직접 정의한 UserDAOException 클래스에서 RuntimeException을 사용해 전환하는것으로 이루어졌다. 123456try{ ~} catch (SQLException e) { throw new UserDAOException(); //원래는 RuntimeException.} 이처럼 @ExceptionHandler Annotation을 사용한 Exception 핸들러 매핑은 개별적인 예외처리 보다 모든 Exception을 한 메서드에서 처리 할 수 있다는 점 해당 퍼를리케이션의 같은 종류의 예외처리로 인한 복구의 가능성이 높아진다는점 각각의 다른 예외상황들에 관해 각기 다른 뷰를 반환 할 수 있다는 장점이 있다.","link":"/2019/09/18/19.05.17 Spring DAY-3 예외처리/"},{"title":"","text":"오브젝트와 의존관계 오브젝트와 의존관계 난감한 DAO 🔌 JDBC DAO의 분리 공통기능을 독립시키기 상속을 통한 확장 DAO의 확장 새로운 객체를 생성하는 경우 스프링은 오브젝트에 관한 설계와 동작 검증, 구조를 지속적으로 개선하는 테스트등의 여러가지지식이 요구되는 프레임워크로써 오브젝트에 대한 관심과 객체지향 기술 이 제공하는 혜택과 목적성을강조한다. 난감한 DAO 데이터 베이스를 이용해 데이터를 조회하거나 조작하는 기능을 전담하는 오브젝트이다.자바 빈 객체를 DB라고 봤을때 그 객체에 관한 CRUD같은 DB관련 기능들을 정의해 사용하는 오브젝트이다. ✔️ JavaBean 디폴트 생성자를 가지고있고, getter/setter 프로퍼티를 소유한 오브젝트 ###🔌 JDBC 드라이버 로딩 (JDBC Load) Class.forName(“드라이버 Path”) Class 클래스가 클래스의 정보(필드, 메서드 클래스의 종류)를 담는 메타 클래스이고JVM은 해당 클래스의 정보를 로드한다. DB 연결 Connection DriverManager.getConnection(url, ID, PWD) Connection 객체를 생성한후 DriverManager에서 시스템 프로퍼티 “jdbc.drivers”에 참조된 드라이버 클래스를 로드한다. 이후 Connection 객체에 할당 쿼리 생성 및 질의 1234567PreparedStatement psmt = null;psmt = conn.prepareStatement(\"SQL문\");Statement stmt = null;stmt = conn.createStatement(\"SQL문\"); ✔️ PreparedStatement는 쿼리에 ?로 매개변수를 받아 실행 가능 쿼리 실행 psmt.executeUpdate() INSERT UPDATE DELETE 같은 값을 받아오지 않는 쿼리문은 psmt.executeUpdate()로 실행 psmt.executeQuery() SELECT 처럼 결과 테이블이 필요한 쿼리문은 쿼리 실행 이전에 ResultSet객체를 생성한후 psmt.executeQuery()를 할당한다. ResultSet 처리 123456while(rs.next()) { int i=1; int id = rs.getInt(i++); String name = rs.getString(i++); String addr = rs.getString(i++); } Close() 1234567891011121314151617181920if (rs!=null) { try { rs.close(); } catch (SQLException e) { }}if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { }}if(conn!=null) { try { conn.close(); } catch (SQLException e) { }} ✔️ Open한 객체들의 역순으로 close 시킨다. DAO의 분리 위의 6단계를 거친 DAO객체의 메서드 처리 과정은 객체지향의 특징과는 어긋나있는 점이 많다.개발에게는 객체지향의 확장성과 유연함 을 고려한 설계가 요구되며각각의 객체들에 대한 관심사의 구분 이 적절하게 나누어 질 수 있도록 설계해야 한다. Connection 생성 과정의 중복 👉 독립적인 메소드를 만들어 분리 : 공통의 기능을 담당하는 메소드로 중복을 제거하는 것을 리팩토링에서는 메소드 추출이라 한다. 공통기능을 독립시키기 위에서 리팩토링한 DAO를 사용할 경우 Connection의 중복은 제거되었지만 객체지향의 유연한 특징은 발휘되지 않았다.DAO를 다른 환경에서 이용할때의 부분적인 수정이 이루어 지도록 하는 방법도 존재한다. 상속을 통한 확장 구현해놓은 메소드를 추상화 시키고 DAO 클래스를 상속받는 서브클래스를 만든다.즉, 클래스의 계층구조를 나누어 분리시키는 것이다. ✔️ 위와같이 클래스를 추상화 시킨후 각각의 서브클래스들로부터 부분적인 부분을각각 구현하는 방법을 ‘템플릿 메소드 패턴’ 이라고 한다. ❗ 상속을 이용한 확장은 간단하면서도 효과적이지만 다른 객체를 상속받을 수 없다는 점❗ 부모 클래스의 변경이 이루어 질 경우 적합성이 보장되지 않는다는 단점이 존재한다. DAO의 확장 위에서 언급한 데이터 접근 로직과 DB연결 방법을 고려하는것은 다른 변화의 성격을 띄고있다.앞서 언급한 각각의 방법 외에 다른 방법으로는 완전한 독립적인 클래스로 만드는것이 있다. 새로운 객체를 생성하는 경우새로운 객체를 생성하여 사용하는것은 다시 유연성 확보에 관한 문제점을 야기한다. 인터페이스의 도입은 이러한 문제점을 해결할 수 있는 해결책으로 제시된다. 인터페이스를 이용한 추상화 방법은 클래스와 함께 인터페이스도 전달하여 개발자에게 전달된 인터페이스의 구현을 행하도록 하는것이다.","link":"/2019/09/18/19.05.20 1장 오브젝트와 의존관계/"},{"title":"","text":"Interceptor &amp; Annotation ✔️ HTTP Request / Response의 Controller 앞뒤에 요청/응답을 가로채 작업을 수행하는 역할 ✔️ HandlerInterceptor 인터페이스를 이용해 구현한다. implements : preHandle() postHandle() afterCompletion() ✔️ 예제에서는 세션처리에 관련된 @Auth 를 구현 해봤다. 필터는 그림에서 보이듯 Servlet의 앞에서 관여하며 Interceptor는 Controller의 앞뒤에서 이루어진다 HandlerInterceptorAdapterInterceptor의 구현시 상속받아 이용할 수 있는 추상 클래스이다.Interceptor 구현시 필요한 HandlerInterceptor 인터페이스를 기본으로 구현한클래스 이기 때문에 Method만 Override하여 구현 할 수 있다. Annotation AOP의 구성요소인 JoinPoint 로써 Annotation의 삽입을 통해 컴파일시(When) 해당 타겟 메서드에 추가적인 코드를 실행하는것이다. @Target : 어노테이션의 타켓을 지정 ( FIELD, METHOD, PARAMETER, TYPE) @Retention : 어노테이션의 지속 (보존) 기간을 지정( RUNTIME, SOURCE ) 12345@Target( ElementType.METHOD )@Retention( RetentionPolicy.RUNTIME )public @interface Auth {} Annotation Flow","link":"/2019/09/18/19.05.23 Interceptor 와 Annotation/"},{"title":"","text":"AOP (관점 지향 프로그래밍) AOP (관점 지향 프로그래밍) AOP의 구성요소 *Target *Aspect *Advice - Interceptor (What?) *Join Point - When? *Point Cut - Where? *Proxy *Weaving ✔️ 애플리케이션 전체에서 사용되는 기능을 재사용✔️ 횡단 관심사의 분리 (Seperation of Concern) 기존의 OOP와는 다른 관점으로부가기능적인 측면에서의 공통된 요소를 강조하는 것이다. OOP AOP 비즈니스 로직 각각의 모듈에 필요한 부가기능 핵심관리 모듈(class or service)마다 필요한 모듈(code)을 직접 호출하지않고 Weaving하여 횡단관심 코드가 삽입 재사용 되도록 하는 방법. 각 모듈들의 횡단 관심사가 무엇인지 파악하는 능력이 필요하다. 대표적인 예로 스톱워치, 로깅, 트랜잭션, 보안, 인증, 리소스풀링 에러체크, 세션관리등이 있다. 1990년대 후반 Java를 확장해 AOP를 지원하고 컴파일시 횡단 관심 모듈이 삽입되는 최초의 프레임워크 AspectJ의 출시. AspectJ 5.0의 발표 이후 자바 5.0에서 추가된 Generic, Annotation을 활용하게 되면서 자바에서도 개발이 가능해졌다. Spring 2.0의 경우 AspectJ의 라이브러리를 활용해 Annotation 해석기능을 수행한다. AOP의 구성요소*Target공통 관심 모듈을 적용할 대상들 *Aspect부가기능 모듈 그 자체를 Aspect라 한다.Aspect는 기능을 정의한 어드바이스와 어드바이스를 어디에 적용할지 결정하는 포인트컷을 내포하고있다. *Advice - Interceptor (What?)횡단 관심사의 분리로 실질적인 부가기능을 담당하는 구현체 *Join Point - When?어드바이스가 적용될 수 있는 위치(시점)Spring에서는 메소드 조인포인트만 제공한다.예제에서는 Around시점에 Advice를 적용시켜 각 메서드의 시간측정을 구현해봤다. *Point Cut - Where?횡단 관심사가 적용될 대상 을 선정하는 방법 (Which method?) *Proxy타겟의 요청을 먼저 가로채서 어드바이스에 등록된 기능을 먼저 사용한 후 요청 된 메소드의 기능을 수행하는 오브젝트 *Weaving 어드바이스를 삽입하는 과정 지정된 객체에 Aspect를 적용해 새로운 프록시 객체를 생성하는 과정 그 자체를 얘기한다. 프록시 객체의 생성 과정을 위빙이라고 생각하자 Spring에서는 Runtime에 프록시가 생성되어 위빙이 이루어진다고 할 수 있다. 실습한 예제에서는 Service 계층에 관여하여 @Before(“execution(package info)”) / @After 등을 통해 JoinPoint(when) 에 대한 학습을 진행했었다.","link":"/2019/09/18/19.05.23 AOP/"},{"title":"","text":"Message Converter &amp; LogMessage Converter XML이나 JSON을 이용한 Ajax처리와 Client - Server 사이의 메세지 전송에 이용됨 Request Body / Response Body 구조 메서드 파라미터에 @RequestBody, 메서드 반환타입으로 @ResponseBody 혹은 메서드 어노테이션으로 이용 Message Converter는 AnnotationMethodHandlerAdpater 인터페이스를 통해 하나이상의 컨버터가 등록, 선택 동작하게 된다. &lt;mvc:annotation-driven/&gt;에서 자동으로 등록된다. &lt;mvc:annotation-driven/&gt; 디폴트 bean과 함께 Jackson과 JAXB가 라이브러리로 등록 되어있을 경우 같이 등록된다. ✔️ 주로 Ajax처리의 상태 메세지 전송을 주고받을때 이용된다. Log 예제에서는 SLF4J의 구현체중 하나인 Logback을 📝logback.xml을 적용해 이용하기위해 JCL은 제외하고 사용했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;appender name=\"consoleAppender\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;file&gt;/logex/ExceptionLog.log&lt;/file&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;Pattern&gt; %d{HH:mm:ss.SSS} [%thread] %-5level %logger{5} - %msg%n &lt;/Pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"fileAppender2\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;/logex/logex2.log&lt;/file&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;Pattern&gt; %d{HH:mm:ss.SSS} [%thread] %-5level %logger{5} - %msg%n &lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;FileNamePattern&gt;/logex/logex2.%i.log.zip&lt;/FileNamePattern&gt; &lt;MinIndex&gt;1&lt;/MinIndex&gt; &lt;MaxIndex&gt;10&lt;/MaxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;50KB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;appender name=\"fileAppender3\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;/logex/logex3.log&lt;/file&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;Pattern&gt; %d{HH:mm:ss.SSS} [%thread] %-5level %logger{5} - %msg%n &lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;FileNamePattern&gt;/logex/logex3.%i.log.zip&lt;/FileNamePattern&gt; &lt;MinIndex&gt;1&lt;/MinIndex&gt; &lt;MaxIndex&gt;10&lt;/MaxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;1MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!-- com.cafe24.logex2 아래 패키지 로그들만 \\logex\\logex2.log 파일에만 출력하는 로거 --&gt; &lt;logger name=\"com.cafe24.mysite2.exception\" level=\"debug\" additivity=\"false\"&gt; &lt;appender-ref ref=\"fileAppender2\" /&gt; &lt;appender-ref ref=\"consoleAppedner\" /&gt; &lt;/logger&gt; &lt;logger name=\"com.cafe24.logex2\" level=\"debug\" additivity=\"false\"&gt; &lt;appender-ref ref=\"fileAppender2\" /&gt; &lt;/logger&gt; &lt;!-- com.cafe24.logex3 아래 패키지 로그들만 \\logex\\logex3.log 파일과 콘솔로 출력하는 로거 --&gt; &lt;logger name=\"com.cafe24.logex3\" level=\"warn\" additivity=\"false\"&gt; &lt;appender-ref ref=\"fileAppender3\" /&gt; &lt;appender-ref ref=\"consoleAppender\" /&gt; &lt;/logger&gt; &lt;!-- 루트(글로벌) 로거 --&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"consoleAppender\" /&gt; &lt;/root&gt;&lt;/configuration&gt; logback.xml&lt;appender&gt; 의 구성 저장될 로그파일의 경로와 출력될 형식을 지정하고 &lt;rollingPolicy&gt; 속성을 통해 &lt;triggeringPolicy&gt;의 용량이 넘을 경우의 압축 형식을 만든다. &lt;logger&gt; name : 로깅할 패키지의 범위 지정 (미지정시 글로벌 루트에 맞춰진다) level : 로깅 레벨의 지정 (debug, info, warn, error) additivity : 자식로그를 추가할지의 여부 (false면 포함)","link":"/2019/09/18/19.05.23 Message Converter & Log/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/06/hello-world/"},{"title":"DUNPIC.NET 개발기","text":"✒️ 개요먼저 프로젝트 주제를 정하게 된 과정을 적어보자면, 내가 처음 Spring으로 진행했던 프로젝트는 블로그 였는데 글쓰는 것에 대한 막연한 동경이 있다는 점도 있었지만, 개발자가 블로그를 운영해야 할 이유 를 감명깊게 봐서였다. 하지만 블로그 특성상 시스템적인 부분외에는 참고할 피드백이나, 의견을 얻기가 어려웠기 때문에 다음 프로젝트에서는 서비스를 만들어 보고 싶다는 생각을 가지고있었다. 그러던 와중 그 당시에 하던 게임에서 오픈 API를 제공 한다는 소식을 접했고“게임중에 느꼈던 불편한 점들을 해결해준다면 이게 서비스가 아닐까?”라는 생각에 시작하게 됐다. ❓ 뭘 개발했나?힘 +100 짜리 무기가 있다고 치자, 이 무기의 능력치를 더해주는 시스템을 마법부여라고 한다. 마법부여를 하기 위해서는 카드가 필요한데 예시를 한번 살펴보자. +15 만큼의 성능을 내는 1500만원의 카드 A가 있다. +10 만큼의 성능을 내는 50만원의 카드 B가 있다. 데미지가 산출 되는 단위가 % 연산으로 계산되어 억에서 조단위까지 차이나기 때문에 초보자의 입장에서는 +5만큼의 성능을 위해 A를 골라 1450만원을 더 투자하기란 쉽지 않은 이야기다. 결국, 합리적인 소비를 위해 각 아이템의 가격을 보며 가치를 따져보기 위해서는 엄청나게 많은 상품의 가격을 일일히 검색해보며 비교해봐야 하는 문제점이 존재했고, 같은 옵션이라도 장비의 종류, 옵션의 수치에 따라 각각 다른 카드가 필요하다 이 점을 해결하기위해 부위별 해당하는 모든 옵션들과 수치들을 담고있는 테이블을 만들어, 사용자의 선택을 통해 선택된 특정 부위에 특정 옵션을 가진 무기 &gt; 힘 : 무기에 힘을 + 해주는 카드들을 보여준다. 카드들을 보여주고 현재 경매장에 올라와있는 가격을 확인 할 수 있는 기능을 만들었다. 👀 어떤 과정을 거쳤나.처음 기능에 대한 아이디어를 떠올렸을때는 정리되지 않은 아이디어를 어떻게 구현할까에 대한 고민들을 많이했다. 블로그는 단순히 분류하자면 글쓰기, 글목록 표시, 글 내용 부분정도만 들어갔었지만, 이번 프로젝트에서는 사용자의 선택지를 전달받아 또다른 선택지를 띄워주고, 결과를 반환하는 기능 뿐만아니라 커뮤니티를 위한 게시판, 게임과 관련된 콘텐츠도 직접 제작해보며 시간을 보냈다. 마법부여 기능의 선택지를 받아야하는데 생각보다 적당한 방식이 떠오르지 않아 네이버 검색탭을 보고 &lt;ul&gt;태그와 &lt;li&gt;태그를 통해 선택지를 나열하고 현재 선택된 요소에 border-bottom으로 색깔을 표시해주는것으로 구현해봤다. 실시간 가격의 경우 네오플 오픈 API에서 제공해준 경매장 API를 통해 해결했다. 아이템ID나 아이템 이름을 파라미터에 붙여주면 최저가, 평균가도 한번에 제공 받을수 있어 이부분은 크게 무리없이 구현했다. 문제는 아이템 파라미터였는데, 처음에는 경매장 API에 접근하기 위해서는 아이템 이름만으로 해당 아이템의 최저가와, 평균가를 얻을수 있을것이라고 생각했었기 때문에 아이템 테이블에는 이름만 존재했었다. 문제는 비슷한 이름의 아이템이 존재하기 때문에 경매장에 'ABCD'라는 아이템의 매물이 없을 경우 비슷한 이름인 'ABCE'라는 다른 아이템의 가격이 검색되어 표시되는것이었다. 이 때문에 결국 아이템ID를 포함해 테이블을 새로 만들어야 하나 했지만, 다행히도 이름으로 ID를 검색해내는 API도 제공해줘서 관련 메서드를 하나 더 작성하고 손쉽게 테이블을 수정할 수 있었다 😌 앞서 말했다시피 DB 설계를 주의깊게 하지 않은 탓에, 다른 문제점들이 많았다. 데이터를 추가하는 순서는 무기 - 상의 - 하의 - … 메뉴 순으로 추가를 했는데, 앞 순서에 속한 카드들은 옵션이 두개라서 컬럼을 두개만 배정해서 아이템 이름 첫번째 옵션 두번째 옵션 첫번째 옵션 값 두번째 옵션 값 해리 카드 힘 속도 +15 3% 이런식으로 만들었다. 문제는 마지막 순서인 귀걸이에서 나왔는데 아이템 옵션이 4개라서 몹시 당황 했던 기억이 있다. 지금 생각해보면 기획이나 설계에 관한 시간을 안보내서 벌어진 일이었는데 이 후 진행할 프로젝트에서 얼마나 중요할지 체감하는 순간이었다. 마침 이 프로젝트를 진행할때가 산업기사와 병행하며 공부했을때였는데, 정규화에 대한 이론적인 공부와 함께 이 프로젝트의 DB를 정규화 해보면서 정규화에 대해 더 깊은 이해가 생긴것 같아 아직도 많이 기억에 남는다.(많은 단계를 거치진 않았지만 😅) 📘 얻게 된것 블로그를 진행했을때와는 확실히 달랐다. 피드백의 속도나 질적인 측면에서 유저들이 남겨준 코멘트들을 받을 수 있다는것이 상당히 새로웠다. 로컬에서 RUN해보고 거기서 끝났던 것과는 다르게 이번에는 AWS의 몇몇 서비스들을 이용해봤다. ROUTE53에서 도메인을 구매해 EC2 서버에서 실행시키기도 해봤기 때문에 좀더 본격적(?)으로 진행한 기분이라 웹 개발자가 되어보는 간접적인 경험을 한것 같다. 📝 아쉬웠던 점지금 생각해보면 기능 구현이나 UI에 집착하면서 시간을 너무 많이 소모했었다. 그 당시에는 알지 못했던 로그 관리나 서버관리, 코드 작성을 어떻게 해야할지 같은 점들이 아쉬웠지만 공부를 해보며 아 이때는 이런걸 쓰는게 좋았겠구나!라는 생각이 떠오르게 하는점도 있어 아쉽지만 훗날있을 일들을 위해 좋은 경험이었다고 생각한다. 🌈 마치며DUNPIC.NET 게임에 관한 주제이다 보니 항상 게임내 정보들을 머리에 담고 있어야했고 개발자로서의 고민보다 게임내 컨텐츠를 제공하는 포스팅을 위해 더 많은 시간을 쓰는 내 모습을 보면서 현재는 개발자로서의 역량을 쌓기 위해 더이상의 업데이트는 하고있지 않다. 또한 AWS 프리티어도 끝나고 도메인도 만료되며 게임에 대한 흥미도 잃어버렸기 때문에 서버 운영도 더이상은 하고있지 않은 상태이다. 처음 프로젝트 시작했을때가 떠오른다. 게임 커뮤니티에 사이트를 소개하는 글을 적을때부터 많은 분들이 댓글로 좋은 반응을 남겨주거나, 쪽지로 편하게 할수있어서 너무 좋다는 의견을 접하면서 그 마음에 보답하고자 더 사이트내 요소들에 대해 고민하는 시간들을 보내던 와중 게임 사이트 메인에도 소개 링크가 개제되어어 그날 방문자가 7천명을 기록하기도 했었다. 프로젝트를 시작할때 기대했던것보다 더 큰호응을 받게되어서 너무 좋은 경험을 한것 같다 :)","link":"/2018/11/21/18.11.22 DUNPICNET 개발기/"},{"title":"독학사 후기","text":"컴퓨터과학 독학사 4단계 후기 독학사 시험 결과가 합격으로 나와 지난번 썼던 독학사 후기를 다시 읽어보는데 내용이 마음에 안들어 합격후기로 다시 써보려고 한다. 먼저, 독학사 후기를 적게된 이유는 독학사 준비 기간동안 6개의 과목을 공부했는데 힘들때마다 합격후기를 읽으며 마음을 다시 잡을수 있게 해주던 선배님들처럼 나도 후기를 적어보고싶었다. 사실 합격발표전에는 독학사를 준비하는 분들께 조금이라도 도움을 주고 싶다는 마음이 있었지만 결과확신을 나도 못하던때라 조심스러운 마음에 정보에 대한 내용보다는 후기에 가까운 글을 썼었다. 다행히 바로 어제인 11월 26일 합격 소식을 확인했고, 이전 글 보다는 덜 부담스러운 마음가짐으로 글을 써보려고 한다. ❓ ‘독학사’에 대해 혹시 `독학사`에 대해 모르는 분들이 있을수 있기에 설명해보자면 독학학위제는 독학자에게 학사 학위 취득의 기회를 부여하기 위해 국가가 시험에 합격한 사람에게 학사 학위를 수여하는 제도이다. - 위키백과 한마디로 4년제 학사학위를 딸수있는 국가 검정 시험이다. 고등학교 졸업학력을 규정하는 국가 검정 시험인 검정고시와 비슷하다. 독학사 시험은 1년에 4단계의 시험이 있고 각 단계를 모두 통과해야 학사 학위를 취득하게 된다. 내 경우에는 3년제 전문대를 졸업했기때문에 3단계 까지의 시험이 면제되고 4단계만 통과하면 학사학위를 얻을수 있는것. 4단계 시험은 총 6과목으로 구성되는데 나는 교양과목인 국어 영어 2개를 선택했고 전공과목은 컴퓨터시스템구조 네트워크 자료구조 운영체제 4개로 모든사람이 동일하다. 📙 시험준비에 어려웠던점. 독학사 시험을 준비하며 가장 힘들었던 점은 지난 시험에 나왔던 기출문제가 없다는 점이었다. 이 말은 문제은행 방식이 아니기 때문에 개념에 대한 기본적인 이해를 필수로 다소 지엽적이라고 할 수 있는 문제들이 시험에 나올수 있다는 것이다. 지엽적인 문제의 내용이 처음보는 내용인 경우도 있어 만점을 맞기에는 상당히 어려운 시험이다. 특히 문제 출제의 범위와 예시문제를 통해 공부해야될 내용을 판단하는점이 어려웠다. 필자도 처음에는 위와같은 문제로 걱정을 많이 했었지만 시험을 치른 입장에서는 합격에는 아무 문제 없다는 생각이다. 합격 불합격은 6과목의 총점이 360점 즉 평균 60점만 넘기면 되기 때문인데 느낀바로는 iMBC 교재의 기본적인 개념이나 iMBC 모의고사 문제 분석 만으로도 각 과목당 60점은 충분하다. ✏️ 어떤식으로 공부했는지 내가 공부 했던 경험으로 말해보자면 프로젝트와 산업기사 시험을 치르고 본격적인 독학사 공부는 9월부터 시작했다. (졸업 후 독학사 시험을 치기위해 틈틈히 공부한것들을 제외하고) 9월부터 시험일인 10월 28일까지의 기간동안 준비를 한셈인데 인강같은 것들은 전혀 수강하지 않았다. iMBC기준으로 4단계 강의료만해도 90만원인데 집안사정이 90만원이나 쓰기에는 여유롭지가 않아서 지금생각하면 무슨 자신감인지 모르겠지만 모든 과목을 독학으로 공부했다. 교재는 iMBC 컴퓨터 과학과 4단계 책 6권을 파이널 모의고사 문제까지 포함해 모두 구매했다. 시험 공부를 시작할때 대략적인 계획을 9월동안 6권 모두 학습하고, 10월 14일까지 모든 문제 풀이 28일까지 총복습으로 지금보면 좀 무식하게 세웠다. 계획을 세울때부터 모든 일정이 밀리면 안되고, 그날 그날 할당량을 모두 소화하기 위해 하루마다 공부량을 체크해서 페이지와 남은 퍼센트를 다이어리에 기록했는데 이 방법이 그래도 꽤 효과적이었다. ![기록1](/images/독학사_후기/diary.jpg) _가끔 일기도 적었다_ 😅 모든 내용을 끝내기에 한달이란 시간은 사실 부족하기도 했지만 그날그날의 할당량은 무조건 소화한다는 마음으로 공부에 임했고 실제로 90퍼센트는 지켰다. 2달간의 시험 준비를 정리해보면 이렇다. **`6과목 전부 노트에 쓰면서 공부` -> `문제 풀이` -> `오답 전부 다시 쓰기, 총정리`** 🚮 버릴건 버리자. 공부할때마다 평가원의 출제방향, 출제 범위를 고려해 벗어나는 내용들은 모두 배제하면서 공부했다. 예를들면 국어의 높임말, 고어같은 내용들은 외운 내용들이 문제로 안나올 가능성이 있다고 생각했다. 평가원에서 시험출제시 iMBC책의 내용만을 참조해서 출제하는것이 아니기 때문이었다. 또한, 독학사 시험에서는 출제 문항수가 정확히 정해져있다. 과연 위에서 말한 국어의 높임말, 고어 같은 내용들이 다른 단원들과 같은 문항수로 나올까? 심지어 평가원에서 제공하는 12문제들 중 1문제도 없다. 심지어 보기에도 안나온다. 시조나 가사 내용들도 주요내용이나 특징들을 밑에서 같이 짧막하게 정리만 하고 넘어갔다. 고대가요 - 공무도하가 - 죽음의 이미지, 공후인, 여성의 목소리 📜 평가원 예시 문제를 완벽히 숙지하자. 시험을 치른 입장에서 생각해보면 평가원에서 나온 문제들이 똑같이 출제된 문제들이 몇개 있었다. 심지어 주관식 문제도 똑같이 나온게 있었는데 변형된 방식이 이랬다. 평가원 문제가 이런식이라면 전송 메시지 M(X)=X^3+X+1 와 생성 다항식 G(X)=X+1 로부터 나머지 R(X)와 실제 전송될 부호화된 메시지 F(X)를 구하면? (객관식) 시험에서는 이렇게 나왔다. M(X)=X^3+x+1 와 G(X)=X+1 로부터 나머지 R(X)를 구하고 부호화된 메시지 F(X)를 풀이과정과 함께 구해라. 풀이과정이 추가된 것처럼 “평가원 문제에서 출제한 주요 개념을 확실히 이해하고있는가?” 의 방향으로 생각해 공부하면 될것같다. 📑 주관식 주관식 문제들은 각 시험마다 4문제씩 10점 총 40점을 차지하기 때문에 굉장히 중요하다. 앞서 얘기한것 처럼 기출문제가 없기 때문에 주관식 대비 문제를 예상하기 어려워서 부담을 많이 가졌었다. 서술형인지, 빈칸 채우기인지, 단답식인지 걱정도 많이했는데 내가 치른 시험에서는 다양한 유형들이 나왔었지만 주관식이라는 문제의 특성으로 인해 난이도가 올라간 경우는 거의 없었다. 서술형도 내 기억으로는 네트워크의 한 문항 정도였고 나머지는 대부분 빈칸 채우기였다. 생각해보면 주관식의 체감 난이도가 생각보다 낮았는데, 대부분을 차지한 빈칸 채우기 문제들의 지문이 헷갈리지 않게 대답을 유도하는 식으로 구성되어 있었고, 채워야하는 빈칸의 &lt;보기&gt;도 제공되는 문제들도 있었기 때문에 점수따기 좋았다. 그러니까 주관식 문제들은 부분점수가 있기 때문에 절대 비우지 말고 뭐라도 채우자. 문제내에 힌트도 많다! 💬 아쉬웠던 점이나 느낀점 개요에서는 독학사 시험을 _\"4단계의 시험만 통과하면 학사학위를 얻을수 있는것.\"_ 이라고 언급했었지만 사실 시험에 대한 두려움이 정말 컸다. 내 경우는 1개의 시험만 통과하면 학위를 따는것이지만, “내가 정말 할수 있을까?” “불합격하면 내년까지 시험 못보는데 그땐 어쩌지?” “졸업 후 취업이 아닌 독학사를 준비하는게 정말 맞는 선택일까?” “불합격하게 된다면 내가 올해 한 공부들은 뭐가되는건가?” “인강도 안보고 독학으로 합격하는게 정말 가능할까?” 라는 생각들로 정말 많은 갈등을 했었지만 그럴때마다 독학사 합격 후기를 보며 마음을 다잡았다. 결과적으로는 합격을 했지만 “내 인생에서 이렇게 열심히 공부해본적이 있을까?” 라는 생각이 들정도로 필사적으로 임했다. 요즘은 합격의 기쁨도 있지만, 내가 한 노력으로 뭔가를 이뤘다는 것에서 업된 기분이다. 부모님이 많이 좋아하시기도 하고 😄 🎓 독학사에 대한 개인적인 생각 독학사 제도 자체에 대한 의의는 제쳐두고 느낀 개인적인 생각으로는 공부하면 합격할수 있는 시험이라고 생각한다. 문제의 지문이나, 보기들이 소위 말하는 함정 문제가 매우 드물다고 생각한다. 내 기준에서는 시험전에 걱정하던 부분보다는 생전 처음보는 개념이나 문제가 나와서 당황한것 외에는 평이했다. 내 입장에서 독학사라는 제도 자체는 정말 이점이 많은 제도였다. 학교를 졸업하고 산업기사 시험을 준비하거나 해보고 싶었던 프로젝트를 하면서 시험을 준비하는 과정들의 끝이 독학사 시험을 합격한것이 되어서 4년제 학교를 다닌것과 같은 셈이 된것같다.","link":"/2018/11/27/18.11.27 독학사 후기/"},{"title":"클라이언트 스토리지","text":"💾 20장 클라이언트 스토리지 📖 자바 스크립트 완벽 가이드 💾 20장 클라이언트 스토리지 🌏 웹 스토리지 🍪 쿠키 🌐 IE User Data 📴 오프라인 웹 애플리케이션 💻 웹 데이터베이스 📁 파일시스템 API 로컬 스토리지와 세션 스토리지 스토리지 생명주기와 범위 스토리지 API ⚡ 스토리지 이벤트 🍪 쿠키 쿠키 저장하기 쿠키값 읽기 애플리케이션 스토리지와 오프라인 웹앱 애플리케이션 캐시 MANIFEST 캐시 업데이트 캐시 상태 캐시 메서드 📖 자바 스크립트 완벽 가이드💾 20장 클라이언트 스토리지🌏 웹 스토리지 문자열 키와 값을 대응시킨 연관 배열인 로컬 스토리지와 세션 스토리지 객체로 구성되어 있다.사용하기 쉽고 너무 크지않은 대용량 데이터를 저장하기에 적합하다. 🍪 쿠키 서버측에서 스크립팅 가능하도록 설계된 오래된 클라이언트 스토리지 메커니즘이다.적은양의 텍스트 데이터르 저장할 경우에만 적절하다.쿠키는 클라이언트에서 사용하더라도 HTTP 요청 시 항상 서버로 전송된다. ###🌐 IE User Data IE 5 이후 버전부터 구현된 전용 클라이언트 스토리지 메커니즘 ###📴 오프라인 웹 애플리케이션 HTML5에서 해당 페이지의 리소스를 캐시할 수 있게 해주는것스트로지의 개념보다는 데이터 그 자체를 의미한다. 💻 웹 데이터베이스 사파리, 크롬, 오페라에서 SQL데이터 베이스를 위한 클라리언트 API (표준화는 실패했다.) 📁 파일시스템 API XMLHttpRequest를 통해 선택할 파일을 업로드 할 수 있게 해주는 File객체를 지원하게되어 만든것. 로컬 스토리지와 세션 스토리지 두 객체 모두 Window객체의 프로퍼티가 정의되어있다.두 객체는 데이터를 얼마나 오래 보관할지 결정하는 생명주기와 접근 가능 대상을 지정하는범위에서 차이가 있다. 1234567localStorage.x = 10;var x = parseInt(localStorage.x); // 데이터를 가져올때는 형변환후 해석해야한다.localStorage.lastRead = (new Date()).toUTCString();localStorage.data = JSON.stringify(data); //인코딩하여 저장후var data = JSON.parse(localStorage.data); //디코딩해서 가져온다. 스토리지 생명주기와 범위 로컬 스토리지의 데이터는 만료 기한이 없고 범위는 문서의 출처(URL)에 한정된다.세션 스토리지의 데이터는 최상위 창이나 해당 스크립트를 실행하는 브라우저의 탭과 생명주기가 같다.세션 스토리지의 범위는 개별 창에 기반을 둔 범위를 갖는다. 스토리지 API method description getItem() 값 저장 setItem() 값 가져오기 removeItem() 값 삭제 clear() 저장된 모든값 제거 ✔️ length는 프로퍼티로 존재한다. ⚡ 스토리지 이벤트 스토리지에 저장된 데이터가 변경될 때마다, 브라우저는 이 데이터를 사용하는 다른 Window객체에스토리지 이벤트를 발생시킨다. key : 설정되거나 삭제된 데이터의 이름 또는 키이다. newValue : 특정 스토리지 데이터의 새로운 값 또는 remoteIte()이 호출됬을때 null을 저장한다. oldValue : 변경되었거나 삭제된 데이터가 가지고 있던 본래 값을 저장한다. url : 스크립트가 포함된 문서의 URL 🍪 쿠키 쿠키 데이터는 웹브라우저와 서버 사이에서 자동으로 전송되므로, 서버 측 스크립트는 클라이언트에서저장한 쿠키의 값을 읽거나 쓸 수 있다. ❗ 쿠키는 어떤 종류의 암호화 기법도 사용하지 않기 때문에 정보 전달시 보호받지 못한다. 쿠키는 메서드가 존재하지 않으며 Document객체의 cookie 프로퍼티를 통해 조작한다. 각 쿠키별로 생명주기와 범위는 개별 지정 할 수 있다. max-age ( 기본적으로는 일시적이다. ) 도메인의 depth를 지정( 경로를 지정 ) 함으로써 쿠키를 공유 할 수 있다. 쿠키 저장하기 일시적인 쿠키를 만드려면 cookie프로퍼티를 문자열 형식으로 설정하자. 1document.cookie = \"version=\" + encodeURIComponent(document.lastModified); name max-age path domain secure 쿠키값 읽기 보통 개별 이름=값 쌍을 분리해 낼 수 있도록 split() 메서드를 사용해야 할것이다.값을 추출한 후 해당 값을 해석하기 위해 decodeURIComponent()에 전달후 JSON.parse()를 사용해객체로 변환한다. 애플리케이션 스토리지와 오프라인 웹앱 애플리케이션 캐시 기능의 추가로 HTML과 CSS JS IMG 등의 파일 자체를 저장하는것이 가능해졌다.애플리케이션이 설치되면 자체적으로 제거하거나 사용자가 직접 지우기 전까지 남아있게 된다. 오프라인 웹앱은 애플리케이션 캐시에 설치된 것으로 동작하고 로컬 스토리지를 사용해 데이터를저장한 다음, 온라인 상태가 되면 저장된 데이터를 서버로 전송하여 동기화하는 방식으로 동작한다. 애플리케이션 캐시 MANIFEST 요청할 URL들의 목록을 담고 있는 매니페스트 파일을 생성한 후 태그에 manifest속성을 설정하여HTML페이지와 연결해준다. MANIFEST의 구성 1234567CACHE MANIFESTmyapp.HTMLmyapp.jsmyapp.cssimages/background.png// resource들 캐시 업데이트 캐시된 웹 애플리케이션은 모든 파일을 캐시에서 불러온다. 브라우저가 오프라인 상태일떄도 마찬가지로매니페스트 파일의 변경을 비동기적으로 확인할 것이다. 브라우저는 캐시 수정 과정에서 다수의 이벤트를 발생시키며, 이벤트 핸들러를 등록할 수 있다. 12345applicationCache.onupdateready = function(){ var reload = confirm(\"애플리케이션 새로고침이 필요합니다. 지금 새로고침 하겠습니까?\"); if (reload) location.reload();} 업데이트할것이 없는 상태 noupdate 업데이트할것이 있는 경우 downloading 이벤트가 발생하고 매니페스트를 참조하며 모든 파일들을 캐시 새 애플리케이션을 처음 로드하는 경우 downloading과 progress 이벤트가 발생되며 다운로드 완료시 updateready가 아닌 cached이벤트가 발생 브라우저가 오프라인 상태인 경우 매니페스트를 확인할 수 없으므로 error 매니페스트를 찾을 수 없는 경우 obsolete 발생 후 애플리케이션을 캐시에서 삭제 캐시 상태 UNCACHED manifest속성을 확인할 수 없음. IDLE 최신버전으로 캐시된 상태 CHECKING 매니페스트 파일을 확인중인 상태 DOWNLOADING 파일들을 다운로드한 다음 캐시에 적용하는 중인 상태 UPDATEREADY 새버전을 다운로드하고 캐시한 상태 OBSOLETE 매니페스트가 없어서 애플리케이션 캐시는 삭제될 예정인 상태 캐시 메서드 update() 애플리케이션의 새 버전을 확인하기 위한 캐시 업데이트 알고리즘을 명시적으로 호출한다. swapCache() 브라우저가 이전 버전의 캐시를 폐기하고 앞으로의 요청들이 새 캐시를 가져올게 해준다. ✔️ 상태값이 UPDATEREADY 이거나 OBSOLETE 일때만 의미가 있다.","link":"/2019/05/13/19.05.13 스토리지/"},{"title":"","text":"🔮 오브젝트와 의존관계 🔮 오브젝트와 의존관계 😖난감한 DAO 🔌 JDBC 💔 DAO의 분리 공통기능을 독립시키기 상속을 통한 확장 DAO의 확장 새로운 객체를 생성하는 경우 관계설정 책임의 분리 &lt; 이해 잘 안되서 다시봐야.. &gt; 📌 원칙과 패턴 ⭐ SOLID SRP (Single Responsibility Principle) 단일 책임 원칙 OCP (Open Closed Principle) 개방 폐쇄 원칙 LSP (Liskov Substitution Principle) 리스코프 치환 원칙 ISP (Interface Segregation Principle) 인터페이스 분리 원칙 DIP (Dependency Inversion Principle) 의존 역전 원칙 💡 전략 패턴 🎯 제어의 역전 (IoC) 스프링은 오브젝트에 관한 설계와 동작 검증, 구조를 지속적으로 개선하는 테스트등의 여러가지지식이 요구되는 프레임워크로써 오브젝트에 대한 관심과 객체지향 기술 이 제공하는 혜택과 목적성을강조한다. 😖난감한 DAO 데이터 베이스를 이용해 데이터를 조회하거나 조작하는 기능을 전담하는 오브젝트이다.자바 빈 객체를 DB라고 봤을때 그 객체에 관한 CRUD같은 DB관련 기능들을 정의해 사용하는 오브젝트이다. ✔️ JavaBean : 디폴트 생성자를 가지고있고, getter/setter 프로퍼티를 소유한 오브젝트 ###🔌 JDBC 드라이버 로딩 (JDBC Load) Class.forName(“드라이버 Path”) Class 클래스가 클래스의 정보(필드, 메서드 클래스의 종류)를 담는 메타 클래스이고JVM은 해당 클래스의 정보를 로드한다. DB 연결 Connection DriverManager.getConnection(url, ID, PWD) Connection 객체를 생성한후 DriverManager에서 시스템 프로퍼티 “jdbc.drivers”에 참조된 드라이버 클래스를 로드한다. 이후 Connection 객체에 할당 쿼리 생성 및 질의 1234567PreparedStatement psmt = null;psmt = conn.prepareStatement(\"SQL문\");Statement stmt = null;stmt = conn.createStatement(\"SQL문\"); ✔️ PreparedStatement는 쿼리에 ?로 매개변수를 받아 실행 가능 쿼리 실행 psmt.executeUpdate() INSERT UPDATE DELETE 같은 값을 받아오지 않는 쿼리문은 psmt.executeUpdate()로 실행 psmt.executeQuery() SELECT 처럼 결과 테이블이 필요한 쿼리문은 쿼리 실행 이전에 ResultSet객체를 생성한후 psmt.executeQuery()를 할당한다. ResultSet 처리 123456while(rs.next()) { int i=1; int id = rs.getInt(i++); String name = rs.getString(i++); String addr = rs.getString(i++); } Close() 1234567891011121314151617181920if (rs!=null) { try { rs.close(); } catch (SQLException e) { }}if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { }}if(conn!=null) { try { conn.close(); } catch (SQLException e) { }} ✔️ Open한 객체들의 역순으로 close 시킨다. 💔 DAO의 분리 위의 6단계를 거친 DAO객체의 메서드 처리 과정은 객체지향의 특징과는 어긋나있는 점이 많다.개발에게는 객체지향의 확장성과 유연함 을 고려한 설계가 요구되며각각의 객체들에 대한 관심사의 구분 이 적절하게 나누어 질 수 있도록 설계해야 한다. Connection 생성 과정의 중복 👉 독립적인 메소드를 만들어 분리 : 공통의 기능을 담당하는 메소드로 중복을 제거하는 것을 리팩토링에서는 메소드 추출이라 한다. 공통기능을 독립시키기 위에서 리팩토링한 DAO를 사용할 경우 Connection의 중복은 제거되었지만 객체지향의 유연한 특징은 발휘되지 않았다.DAO를 다른 환경에서 이용할때의 부분적인 수정이 이루어 지도록 하는 방법도 존재한다. 상속을 통한 확장 구현해놓은 메소드를 추상화 시키고 DAO 클래스를 상속받는 서브클래스를 만든다.즉, 클래스의 계층구조를 나누어 분리시키는 것이다. ✔️ 위와같이 클래스를 추상화 시킨후 각각의 서브클래스들로부터 부분적인 코드를 원하는대로각각 구현하는 방법을 ‘템플릿 메소드 패턴’ 이라고 한다. ❗ 상속을 이용한 확장은 간단하면서도 효과적이지만 다른 객체를 상속받을 수 없다는 점❗ 부모 클래스의 변경이 이루어 질 경우 적합성이 보장되지 않는다는 단점이 존재한다. DAO의 확장 위에서 언급한 데이터 접근 로직(분리)과 DB연결 방법을 고려하는것(상속)은 다른 변화의 성격을 띄고있다.이 말은 각각의 방법이 어느 한 관심사에 집중된 상태로 그 관심사(코드의 중복, 객체지향의 유연함)를 해결하기 위한 방법이라는 말이다. 즉, DAO에 관한 다른 관점이 생긴다면 그 부분으로 관심사가 바뀔수 있고앞서 언급한 각각의 방법 외에 다른 방법으로는 완전한 독립적인 클래스로 만드는것이 있다. 새로운 객체를 생성하는 경우새로운 객체를 생성하여 사용하는것은 다시 유연성 확보에 관한 문제점을 야기한다. DAO클래스가 새로운 객체에 종속되어 상속을 받을때와는 다르게 DAO에 수정이 가해질 수 있기 때문이다. 인터페이스의 도입은 이러한 문제점을 해결할 수 있는 해결책으로 제시된다. 인터페이스는 상속과는 비슷하지만 다르다 상위 개념을 하위에서 받아 사용하는것이 상속이라면 하위 클래스의 특정한 메소드가 반드시 존재하도록 강제하는것이 인터페이스이다 이처럼 인터페이스를 이용한 추상화 방법은 클래스와 함께 인터페이스도 전달하여 개발자에게 전달된 인터페이스의 구현을 행하도록 하는것이다. 즉, DAO의 입장에서 DB연결 방법에 관한 코드를 인터페이스화 시킨다는 의미는 같은 인터페이스를 사용하는 객체들 사이의 규약이 정해져 어떤 상황이든 DB커넥션을 가져올 수 있는것이다. 예제 1-10 에서는 add()`` get()의 메서드 모두 makeConnection() 인터페이스에 정의되어있는 메서드를 사용하는데, 이 코드의 관한 서술과 동작은 인터페이스를 사용하는 다른 객체에서 이루어진다는 것이다. 관계설정 책임의 분리&lt; 이해 잘 안되서 다시봐야.. &gt;📌 원칙과 패턴⭐ SOLID 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion - Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것이다. 높은 응집도 DAO의 경우 Data Access Object라는 목적에 맞게 데이터를 처리하는 기능만을 가지고 있는 모습 낮은 결합도 필요한 관계에서만 interface를 통해 최소한의 연결을 유지하는 모습 ✔️ 다시말해 응집도가 높은 각 모듈을 재사용함으로써, 수정을 최소화하여 유지보수를 용이하기 위함이다. SRP (Single Responsibility Principle) 단일 책임 원칙 하나의 클래스안에 많은 속성을 넣지말고, 필요한 클래스의 역할과 목적에 맞는 속성과 메서드들을 추려 하나의 클래스들로 각각 만들어야 한다. OCP (Open Closed Principle) 개방 폐쇄 원칙 개발 방향을 상위 클래스 혹은 인터페이스를 중간에 두어 직접적인 연동을 피하게 설계한다. LSP (Liskov Substitution Principle) 리스코프 치환 원칙 상속의 개념을 위아래 계층으로 나누는것이 아닌 분류하는것으로 생각하는 관점으로 상속을 확장의 개념으로 설계하는것 ❌ Father harry = new Son(); - 해리라는 이름의 아들이 아버지의 행동을한다.⭕ Animal mickey = new Rat(); - 미키라는 이름의 쥐가 동물의 행동을 한다. ✔️ 클래스의타입 이름 = new 하위클래스();로 기억하자. ISP (Interface Segregation Principle) 인터페이스 분리 원칙 SRP와 같은 원인에 대한 다른 해결책을 제시한다.이미 만들어진 여러개의 속성과 메서드를 인터페이스 를 통해 판단하여 상황에 맞게 사용한다는 방식 DIP (Dependency Inversion Principle) 의존 역전 원칙 상위 클래스가 하위클래스를 의존하는 상황을 인터페이스나 상위클래스를 하나 더 두어 의존하고 있는 방향을 역전 시키는것 ✔️ 의미적으로 OCP 개방 폐쇄 원칙 과 유사하다. 💡 전략 패턴 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 분리시키고, 구현한 로직에 따라 바꿔서사용할 수 있게한 디자인 패턴이다. 앞서 예로든 ConnectionMaker에서 연결방식을 정의하고 이를 구현하고 있는 클래스의 구조에서인터페이스를 통한 각각의 Connection이 전략을 바꿔가며 이용되는것을 말한다. 🎯 제어의 역전 (IoC) 객체의 생성과 사용하는 행위를 담당하는 주체가 Container로 넘어가는것을 말한다. 팩토리 객체의 생성 방법을 결정 하고 그렇게 만들어진 오브젝트를 돌려주는 일 을 하는 객체 다시말해 제어의 역전은 오브젝트가 자신이 사용할 오브젝트를 선택하지 않으며 생성하지도 않고 생성과 반환을 자신이 아닌 다른대상 (팩토리) 에 위임하는 것으로 제어권한을 갖는 하나의 특별한 오브젝트에 의해 결정되고 만들어 지는것이다. ✔️ 서블릿에서의 오브텍트 생성, 메서드 호출이 컨테이너 안에서 이루어 지는것과 같은 개념이다.✔️ 관심의 분리와 책임을 나누는 유연함을 위한 확장 구조를 만드는 과정 자체가 모두 IoC를 위한 작업이었던 셈이다.","link":"/2019/09/18/19.05.21 1장 오브젝트와 의존관계/"},{"title":"","text":"🔮 오브젝트와 의존관계 🔮 오브젝트와 의존관계 😖난감한 DAO 🔌 JDBC 💔 DAO의 분리 공통기능을 독립시키기 상속을 통한 확장 DAO의 확장 새로운 객체를 생성하는 경우 관계설정 책임의 분리 &lt; 이해 잘 안되서 다시봐야.. &gt; 📌 원칙과 패턴 ⭐ SOLID SRP (Single Responsibility Principle) 단일 책임 원칙 OCP (Open Closed Principle) 개방 폐쇄 원칙 LSP (Liskov Substitution Principle) 리스코프 치환 원칙 ISP (Interface Segregation Principle) 인터페이스 분리 원칙 DIP (Dependency Inversion Principle) 의존 역전 원칙 💡 전략 패턴 🎯 제어의 역전 (IoC) 스프링은 오브젝트에 관한 설계와 동작 검증, 구조를 지속적으로 개선하는 테스트등의 여러가지지식이 요구되는 프레임워크로써 오브젝트에 대한 관심과 객체지향 기술 이 제공하는 혜택과 목적성을강조한다. 😖난감한 DAO 데이터 베이스를 이용해 데이터를 조회하거나 조작하는 기능을 전담하는 오브젝트이다.자바 빈 객체를 DB라고 봤을때 그 객체에 관한 CRUD같은 DB관련 기능들을 정의해 사용하는 오브젝트이다. ✔️ JavaBean : 디폴트 생성자를 가지고있고, getter/setter 프로퍼티를 소유한 오브젝트 🔌 JDBC 드라이버 로딩 (JDBC Load) Class.forName(“드라이버 Path”) Class 클래스가 클래스의 정보(필드, 메서드 클래스의 종류)를 담는 메타 클래스이고JVM은 해당 클래스의 정보를 로드한다. DB 연결 Connection DriverManager.getConnection(url, ID, PWD) Connection 객체를 생성한후 DriverManager에서 시스템 프로퍼티 “jdbc.drivers”에 참조된 드라이버 클래스를 로드한다. 이후 Connection 객체에 할당 쿼리 생성 및 질의 1234567PreparedStatement psmt = null;psmt = conn.prepareStatement(\"SQL문\");Statement stmt = null;stmt = conn.createStatement(\"SQL문\"); ✔️ PreparedStatement는 쿼리에 ?로 매개변수를 받아 실행 가능 쿼리 실행 psmt.executeUpdate() INSERT UPDATE DELETE 같은 값을 받아오지 않는 쿼리문은 psmt.executeUpdate()로 실행 psmt.executeQuery() SELECT 처럼 결과 테이블이 필요한 쿼리문은 쿼리 실행 이전에 ResultSet객체를 생성한후 psmt.executeQuery()를 할당한다. ResultSet 처리 123456while(rs.next()) { int i=1; int id = rs.getInt(i++); String name = rs.getString(i++); String addr = rs.getString(i++); } Close() 1234567891011121314151617181920if (rs!=null) { try { rs.close(); } catch (SQLException e) { }}if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { }}if(conn!=null) { try { conn.close(); } catch (SQLException e) { }} ✔️ Open한 객체들의 역순으로 close 시킨다. 💔 DAO의 분리 위의 6단계를 거친 DAO객체의 메서드 처리 과정은 객체지향의 특징과는 어긋나있는 점이 많다.개발에게는 객체지향의 확장성과 유연함 을 고려한 설계가 요구되며각각의 객체들에 대한 관심사의 구분 이 적절하게 나누어 질 수 있도록 설계해야 한다. Connection 생성 과정의 중복 👉 독립적인 메소드를 만들어 분리 : 공통의 기능을 담당하는 메소드로 중복을 제거하는 것을 리팩토링에서는 메소드 추출이라 한다. 공통기능을 독립시키기 위에서 리팩토링한 DAO를 사용할 경우 Connection의 중복은 제거되었지만 객체지향의 유연한 특징은 발휘되지 않았다.DAO를 다른 환경에서 이용할때의 부분적인 수정이 이루어 지도록 하는 방법도 존재한다. 상속을 통한 확장 구현해놓은 메소드를 추상화 시키고 DAO 클래스를 상속받는 서브클래스를 만든다.즉, 클래스의 계층구조를 나누어 분리시키는 것이다. ✔️ 위와같이 클래스를 추상화 시킨후 각각의 서브클래스들로부터 부분적인 코드를 원하는대로각각 구현하는 방법을 ‘템플릿 메소드 패턴’ 이라고 한다. ❗ 상속을 이용한 확장은 간단하면서도 효과적이지만 다른 객체를 상속받을 수 없다는 점❗ 부모 클래스의 변경이 이루어 질 경우 적합성이 보장되지 않는다는 단점이 존재한다. DAO의 확장 위에서 언급한 데이터 접근 로직(분리)과 DB연결 방법을 고려하는것(상속)은 다른 변화의 성격을 띄고있다.이 말은 각각의 방법이 어느 한 관심사에 집중된 상태로 그 관심사(코드의 중복, 객체지향의 유연함)를 해결하기 위한 방법이라는 말이다. 즉, DAO에 관한 다른 관점이 생긴다면 그 부분으로 관심사가 바뀔수 있고앞서 언급한 각각의 방법 외에 다른 방법으로는 완전한 독립적인 클래스로 만드는것이 있다. 새로운 객체를 생성하는 경우새로운 객체를 생성하여 사용하는것은 다시 유연성 확보에 관한 문제점을 야기한다. DAO클래스가 새로운 객체에 종속되어 상속을 받을때와는 다르게 DAO에 수정이 가해질 수 있기 때문이다. 인터페이스의 도입은 이러한 문제점을 해결할 수 있는 해결책으로 제시된다. 인터페이스는 상속과는 비슷하지만 다르다 상위 개념을 하위에서 받아 사용하는것이 상속이라면 하위 클래스의 특정한 메소드가 반드시 존재하도록 강제하는것이 인터페이스이다 이처럼 인터페이스를 이용한 추상화 방법은 클래스와 함께 인터페이스도 전달하여 개발자에게 전달된 인터페이스의 구현을 행하도록 하는것이다. 즉, DAO의 입장에서 DB연결 방법에 관한 코드를 인터페이스화 시킨다는 의미는 같은 인터페이스를 사용하는 객체들 사이의 규약이 정해져 어떤 상황이든 DB커넥션을 가져올 수 있는것이다. 예제 1-10 에서는 add()`` get()의 메서드 모두 makeConnection() 인터페이스에 정의되어있는 메서드를 사용하는데, 이 코드의 관한 서술과 동작은 인터페이스를 사용하는 다른 객체에서 이루어진다는 것이다. 관계설정 책임의 분리&lt; 이해 잘 안되서 다시봐야.. &gt;📌 원칙과 패턴⭐ SOLID 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion - Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것이다. 높은 응집도 DAO의 경우 Data Access Object라는 목적에 맞게 데이터를 처리하는 기능만을 가지고 있는 모습 낮은 결합도 필요한 관계에서만 interface를 통해 최소한의 연결을 유지하는 모습 ✔️ 다시말해 응집도가 높은 각 모듈을 재사용함으로써, 수정을 최소화하여 유지보수를 용이하기 위함이다. SRP (Single Responsibility Principle) 단일 책임 원칙 하나의 클래스안에 많은 속성을 넣지말고, 필요한 클래스의 역할과 목적에 맞는 속성과 메서드들을 추려 하나의 클래스들로 각각 만들어야 한다. OCP (Open Closed Principle) 개방 폐쇄 원칙 개발 방향을 상위 클래스 혹은 인터페이스를 중간에 두어 직접적인 연동을 피하게 설계한다. LSP (Liskov Substitution Principle) 리스코프 치환 원칙 상속의 개념을 위아래 계층으로 나누는것이 아닌 분류하는것으로 생각하는 관점으로 상속을 확장의 개념으로 설계하는것 ❌ Father harry = new Son(); - 해리라는 이름의 아들이 아버지의 행동을한다.⭕ Animal mickey = new Rat(); - 미키라는 이름의 쥐가 동물의 행동을 한다. ✔️ 클래스의타입 이름 = new 하위클래스();로 기억하자. ISP (Interface Segregation Principle) 인터페이스 분리 원칙 SRP와 같은 원인에 대한 다른 해결책을 제시한다.이미 만들어진 여러개의 속성과 메서드를 인터페이스 를 통해 판단하여 상황에 맞게 사용한다는 방식 DIP (Dependency Inversion Principle) 의존 역전 원칙 상위 클래스가 하위클래스를 의존하는 상황을 인터페이스나 상위클래스를 하나 더 두어 의존하고 있는 방향을 역전 시키는것 ✔️ 의미적으로 OCP 개방 폐쇄 원칙 과 유사하다. 💡 전략 패턴 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 분리시키고, 구현한 로직에 따라 바꿔서사용할 수 있게한 디자인 패턴이다. 앞서 예로든 ConnectionMaker에서 연결방식을 정의하고 이를 구현하고 있는 클래스의 구조에서인터페이스를 통한 각각의 Connection이 전략을 바꿔가며 이용되는것을 말한다. 🎯 제어의 역전 (IoC) 객체의 생성과 사용하는 행위를 담당하는 주체가 Container로 넘어가는것을 말한다. 팩토리 객체의 생성 방법을 결정 하고 그렇게 만들어진 오브젝트를 돌려주는 일 을 하는 객체 다시말해 제어의 역전은 오브젝트가 자신이 사용할 오브젝트를 선택하지 않으며 생성하지도 않고 생성과 반환을 자신이 아닌 다른대상 (팩토리) 에 위임하는 것으로 제어권한을 갖는 하나의 특별한 오브젝트에 의해 결정되고 만들어 지는것이다. ✔️ 서블릿에서의 오브텍트 생성, 메서드 호출이 컨테이너 안에서 이루어 지는것과 같은 개념이다.✔️ 관심의 분리와 책임을 나누는 유연함을 위한 확장 구조를 만드는 과정 자체가 모두 IoC를 위한 작업이었던 셈이다.","link":"/2019/09/18/19.05.21 1장 오브젝트와 의존관계_/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Hacker Rank","slug":"Hacker-Rank","link":"/tags/Hacker-Rank/"},{"name":"Organizing Containers of Balls","slug":"Organizing-Containers-of-Balls","link":"/tags/Organizing-Containers-of-Balls/"},{"name":"Implementation","slug":"Implementation","link":"/tags/Implementation/"},{"name":"codility","slug":"codility","link":"/tags/codility/"},{"name":"Static Resource","slug":"Static-Resource","link":"/tags/Static-Resource/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"Picking Numbers","slug":"Picking-Numbers","link":"/tags/Picking-Numbers/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"개발기","slug":"개발기","link":"/tags/개발기/"},{"name":"취업","slug":"취업","link":"/tags/취업/"},{"name":"면접","slug":"면접","link":"/tags/면접/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"DEPLOY","slug":"DEPLOY","link":"/tags/DEPLOY/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"SODID","slug":"SODID","link":"/tags/SODID/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Servlet","slug":"Servlet","link":"/tags/Servlet/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"Adsense","slug":"Adsense","link":"/tags/Adsense/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Cache","slug":"Cache","link":"/tags/Cache/"},{"name":"Storage","slug":"Storage","link":"/tags/Storage/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Service","slug":"Service","link":"/tags/Service/"},{"name":"Context","slug":"Context","link":"/tags/Context/"},{"name":"Server","slug":"Server","link":"/tags/Server/"},{"name":"Infrastructure","slug":"Infrastructure","link":"/tags/Infrastructure/"},{"name":"Cloud","slug":"Cloud","link":"/tags/Cloud/"},{"name":"RAS","slug":"RAS","link":"/tags/RAS/"},{"name":"독학사 후기","slug":"독학사-후기","link":"/tags/독학사-후기/"},{"name":"Client","slug":"Client","link":"/tags/Client/"}],"categories":[{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"Memo","slug":"Memo","link":"/categories/Memo/"},{"name":"후기","slug":"후기","link":"/categories/후기/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"TIL","slug":"Study/TIL","link":"/categories/Study/TIL/"},{"name":"JS","slug":"TIL/JS","link":"/categories/TIL/JS/"},{"name":"JAVA","slug":"Study/TIL/JAVA","link":"/categories/Study/TIL/JAVA/"},{"name":"memo","slug":"memo","link":"/categories/memo/"},{"name":"Java","slug":"TIL/Java","link":"/categories/TIL/Java/"},{"name":"일상","slug":"일상","link":"/categories/일상/"},{"name":"Server","slug":"TIL/Server","link":"/categories/TIL/Server/"},{"name":"개발후기","slug":"개발후기","link":"/categories/개발후기/"}]}